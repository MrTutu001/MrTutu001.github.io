<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!--Page Info-->
    <title>Light Rewrite</title>
    <link rel="icon" href="lightRewriteIconBlack.ico" type="image/x-icon">
    <!-- Imports -->
    <link rel="stylesheet" href="https://cdn.datatables.net/1.11.5/css/jquery.dataTables.min.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.datatables.net/1.11.5/js/jquery.dataTables.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 20px; 
        }
        h1 {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .icon {
            width: 30px; /* Adjust size of the icon */
            height: 30px;
            margin: 0 10px; /* Space between text and image */
        }
        .mirrored {
            transform: scaleX(-1); /* Mirroring the right image */
        }
        .menu-bar { 
            background-color: #f0f0f0; 
            padding: 10px; 
            display: flex; /* Use flex to align items */
            justify-content: flex-start; /* Align items to the left */
            width: 100%; /* Make menu bar full width */
            box-shadow: 0px 2px 5px rgba(0,0,0,0.2); /* Add slight shadow for depth */
            margin-bottom: 10px; /* Space below the menu */
        }
        .dropdown {
            position: relative; /* Position relative to the menu items */
            margin-right: 15px; /* Space between dropdowns */
        }
        .dropdown-content {
            display: none; 
            position: absolute; 
            background-color: white; 
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1;
            white-space: nowrap; /* Prevent wrapping */
        }
        .dropdown:hover .dropdown-content {
            display: block;
        }
        .file-upload, .search-option { margin: 0; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 8px 12px; border: 1px solid #ddd; }
        .dropdown-content a { padding: 8px 12px; display: block; text-decoration: none; }
        .dropdown-content a:hover { background-color: #f1f1f1; }
        .instruction { 
            text-align: center; 
            margin-bottom: 20px; 
            font-style: italic; 
            color: #555; 
            display: block; 
        }
        #searchInfo { 
            text-align: center; 
            margin-bottom: 10px; 
            font-weight: bold; 
            color: #007BFF; 
        }
    </style>
</head>
<body>

    <h1> <!--Title-->
        <img src="lightRewriteIconBlack.ico" alt="Left Icon" class="icon">
        Light Rewrite Web
        <img src="lightRewriteIconBlack.ico" alt="Right Icon" class="icon mirrored">
    </h1>

<div class="menu-bar"> <!--Menu Bar-->
    <div class="dropdown">
        <button>File</button>
        <div class="dropdown-content">
            <div class="file-upload">
                <a href="#" class="upload-trigger">Upload -></a>
                <div class="upload-submenu" style="position: absolute; left: 100%; top: 0; display: none; background-color: white; border: 1px solid #ddd; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);">
                    <label for="fileInput" class="file-upload">
                        <input type="file" id="fileInput" accept=".xml" style="display: none;" onchange="processFile()">
                        <a href="#" onclick="document.getElementById('fileInput').click(); return false;">XML</a>
                    </label>
                    <label for="csvFileInput" class="file-upload">
                        <input type="file" id="csvFileInput" accept=".csv" style="display: none;" onchange="processCSVFile()">
                        <a href="#" onclick="document.getElementById('csvFileInput').click(); return false;">CSV</a>
                    </label>
                    <label for="xlsxFileInput" class="file-upload">
                        <input type="file" id="xlsxFileInput" accept=".xlsx" style="display: none;" onchange="processXLSXFile()">
                        <a href="#" onclick="document.getElementById('xlsxFileInput').click(); return false;">Excel</a>
                    </label>
                </div>
                <script>
                    document.querySelector('.upload-trigger').addEventListener('mouseover', function(e) {
                        document.querySelector('.upload-submenu').style.display = 'block';
                    });
                    document.querySelector('.file-upload').addEventListener('mouseleave', function(e) {
                        document.querySelector('.upload-submenu').style.display = 'none';
                    });
                </script>
            </div>
            <div class="showInfo">
                <a href="#" onclick="getShowInfo()">Show Info</a>
            </div>
            <div class="clearData">
                <a href="#" onclick="clearStoredData()">Reset</a>
            </div>
        </div>
    </div>

    <div class="dropdown">
        <button>Tools</button>
        <div class="dropdown-content">
            <div class="tools">
                <a href="#" onclick="populateAddressFromDimmer()">Dimmer to Address</a>
            </div>
            <div class="tools">
                <a href="#" onclick="compareCSVWithOriginal()">Compare</a>
            </div>
        </div>
    </div>

    <div class="dropdown">
        <button>Views</button>
        <div class="dropdown-content">
            <div class="views">
                <a href="#" onclick="showMainView()">Main</a>
            </div>
            <div class="views">
                <a href="#" onclick="createSpreadsheet()">Work Notes</a>
            </div>
            <div class="views">
                <a href="#" onclick="showAllColumnsView()">All Data</a>
            </div>
        </div>
    </div>
    
    <div class="dropdown">
        <button>Search</button>
        <div class="dropdown-content">
            <div class="search-option">
                <a href="#" onclick="searchByChannel()">Channel</a>
            </div>
            <div class="search-option">
                <a href="#" onclick="searchByAddress()">Address</a>
            </div>
            <div class="search-option">
                <a href="#" onclick="searchByPosition()">Position</a>
            </div>
            <div class="search-option">
                <a href="#" onclick="resetSearch()">Reset</a> <!-- Reset option added -->
            </div>
        </div>
    </div>

    <div class="dropdown">
        <button>Exports</button>
        <div class="dropdown-content">
            <div class="exports">
                <a href="#" class="export-trigger">Paperwork -></a>
                <div class="exports-submenu" style="position: absolute; left: 100%; top: 0; display: none; background-color: white; border: 1px solid #ddd; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);">
                    <div class="exports">
                        <a href="#" onclick="exportChannelHookup()">Channel Hookup</a>
                    </div>
                    <div class="exports">
                        <a href="#" onclick="exportInstrumentSchedule()">Instrument Schedule</a>
                    </div>
                    <div class="exports">
                        <a href="#" onclick="exportColorCount()">Color Count</a>
                    </div>
                    <div class="exports">
                        <a href="#" onclick="exportInstrumentTypeCount()">Instrument Count</a>
                    </div>
                    <div class="exports">
                        <a href="#" onclick="exportWorkNotes()">Work Notes</a>
                    </div>
                </div>
                <script>
                    document.querySelector('.export-trigger').addEventListener('mouseover', function(e) {
                        document.querySelector('.exports-submenu').style.display = 'block';
                    });
                    document.querySelector('.exports').addEventListener('mouseleave', function(e) {
                        document.querySelector('.exports-submenu').style.display = 'none';
                    });
                </script>
            </div>
            <div class="exports">
                <a href="#" onclick="generatePatchFile()">EOS Patch</a>
            </div>
            <div class="exports">
                <a href="#" onclick="exportTableToCSV()">CSV</a>
            </div>
        </div>
    </div>
    
</div>

<div class="instruction" id="instructionBox2">"Perform a complete export on exit" in Vecorworks</div> <!-- Instruction box positioned below the menu -->
<div class="instruction" id="instructionBox">Use the File menu to upload an XML file.</div> <!-- Instruction box positioned below the menu -->
<div class="instruction" id="instructionBox3">Instructions on how to get XML file:</div> <!-- Instruction box positioned below the menu -->
<div class="instruction" id="instructionBox4">In Vectoworks go: Spotlight > Spotlight Settings > Spotlight Preferences > Lightwright > Use Automatic Lightwright Data Exchange > Perform a complete export on exit > OK</div> <!-- Instruction box positioned below the menu -->


<div id="searchInfo" style="display: none;">Currently Searching: <span id="searchCriteria"></span></div> <!-- Search info box -->

<table id="dataTable" class="display" style="display: none;">
    <thead>
        <tr> <!--Data Point Add-->
            <th>Channel</th>
            <th>Position</th>
            <th>Unit</th>
            <th>Purpose</th>
            <th>Type</th>
            <th>Dimmer</th>
            <th>Address</th>
            <th>Color</th>
            <th>Gobo</th>
            <th>Accessories</th>
        </tr>
    </thead>
    <tbody id="tableBody">
    </tbody>
</table>

<script>
//Version
const version = 'v1_7_5'
//Globals    
let originalData = []; // Global variable to store original data
let tableInitialized = false; // Keep track of whether the DataTable has been initialized
let instrumentData = []; //Globalize instrumeData?
let uploadedFileName = ''; // Global variable to store the uploaded file name
// Global variables for show information
let showName = '';
let designer = '';
let headElectrician = '';
// Add this at the top of your script section, with other global variables
let workNotesContainer = null; // Global reference to work notes container
const workNoteHeaders = ['Channel', 'Position', 'Unit', 'Purpose', 'Type', 'Dimmer', 'Address', 'Color', 'Gobo', 'Accessories', 'Notes'];

// Add these functions to handle saving/loading state
function saveState() {
    const state = {
        originalData,
        uploadedFileName,
        showName,
        designer,
        headElectrician,
        workNotes: workNotesContainer ? workNotesContainer.innerHTML : null,
        allColumnsView: document.getElementById('allColumnsView') ? document.getElementById('allColumnsView').innerHTML : null,
        version // Include version for compatibility checking
    };
    localStorage.setItem('lightRewriteState', JSON.stringify(state));
}

function loadState() {
    const savedState = localStorage.getItem('lightRewriteState');
    if (savedState) {
        const state = JSON.parse(savedState);
        
        // Version check
        if (state.version !== version) {
            localStorage.removeItem('lightRewriteState');
            return false;
        }

        originalData = state.originalData;
        uploadedFileName = state.uploadedFileName;
        showName = state.showName;
        designer = state.designer;
        headElectrician = state.headElectrician;

        // Restore the table if there's data
        if (originalData.length > 0) {
            document.getElementById('dataTable').style.display = 'block';
            document.getElementById('instructionBox').style.display = 'none';
            document.getElementById('instructionBox2').style.display = 'none';
            document.getElementById('instructionBox3').style.display = 'none';
            document.getElementById('instructionBox4').style.display = 'none';
            
            // Populate the table
            const tableBody = document.getElementById('tableBody');
            tableBody.innerHTML = '';
            originalData.forEach(item => {
                const accessoriesText = item.accessories && item.accessories.length > 0
                    ? item.accessories.map(acc => acc.type || "Unknown").join("; ")
                    : "";
                
                const row = `<tr>
                    <td>${item.channel}</td>
                    <td>${item.position}</td>
                    <td>${item.unit}</td>
                    <td>${item.purpose}</td>
                    <td>${item.type}</td>
                    <td>${item.dimmer}</td>
                    <td>${item.address}</td>
                    <td>${item.color}</td>
                    <td>${item.gobo}</td>
                    <td>${accessoriesText}</td>
                </tr>`;
                tableBody.innerHTML += row;
            });

            // Initialize or refresh DataTable
            if (!tableInitialized) {
                $('#dataTable').DataTable({
                    searching: false,
                    paging: false,
                    info: false,
                    order: [],
                    columnDefs: [{
                        targets: 1,
                        orderData: [1, 2],
                    }]
                });
                tableInitialized = true;
            } else {
                $('#dataTable').DataTable().clear().rows.add($(tableBody).children()).draw();
            }
        }

        resetSearch();

        // Restore work notes if they exist
        if (state.workNotes) {
            workNotesContainer = document.createElement('div');
            workNotesContainer.id = 'workNotesTable';
            workNotesContainer.style.overflowX = 'auto';
            workNotesContainer.innerHTML = state.workNotes;
            workNotesContainer.style.display = 'none';
            document.body.appendChild(workNotesContainer);
        }

        // Restore allColumnsView if it exists
        if (state.allColumnsView) {
            const container = document.createElement('div');
            container.id = 'allColumnsView';
            container.style.overflowX = 'auto';
            container.innerHTML = state.allColumnsView;
            container.style.display = 'none';
            document.body.appendChild(container);
        }

        return true;
    }
    return false;
}

function processFile() {
    const fileInput = document.getElementById('fileInput');
    const file = fileInput.files[0];
    if (!file) {
        alert('Please select an XML file.');
        return;
    }

    // Store the uploaded file name (without the extension) for later use
    uploadedFileName = file.name.replace(/\.[^/.]+$/, ""); // Remove file extension

    const reader = new FileReader();
    reader.onload = function(event) {
        try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(event.target.result, "text/xml");

            const instrumentData = xmlDoc.querySelector("InstrumentData");
            const instruments = instrumentData ? Array.from(instrumentData.children) : [];

            if (instruments.length <= 0) {
                alert("No instrument entries found in the XML file.");
                return;
            }

            const tableBody = document.getElementById('tableBody');
            tableBody.innerHTML = '';
            originalData = [];

            // Start from the 6th instrument (index 5) to skip the first 5
            for (let i = 5; i < instruments.length; i++) {
                const instrument = instruments[i];
                // Create a data object to store ALL properties
                const fullData = {};
                
                // Store all elements as properties
                Array.from(instrument.children).forEach(child => {
                    fullData[child.tagName.toLowerCase()] = child.textContent || '';
                });

                // Parse accessories specifically
                const accessories = [];
                const accessoriesElement = instrument.querySelector('Accessories');
                if (accessoriesElement) {
                    const accessoryItems = Array.from(accessoriesElement.children);
                    for (const accessory of accessoryItems) {
                        const accessoryData = {};
                        Array.from(accessory.children).forEach(child => {
                            accessoryData[child.tagName.toLowerCase()] = child.textContent || '';
                        });
                        accessories.push(accessoryData);
                    }
                }
                fullData.accessories = accessories;

                // Create table row with only the expected columns
                const row = `<tr> 
                    <td>${fullData.channel || ''}</td>
                    <td>${fullData.position || ''}</td>
                    <td>${fullData.unit_number || ''}</td>
                    <td>${fullData.purpose || ''}</td>
                    <td>${fullData.inst_type || ''}</td>
                    <td>${fullData.dimmer || ''}</td>
                    <td>${fullData.absolute_address || ''}</td>
                    <td>${fullData.color || ''}</td>
                    <td>${fullData.template || ''}</td>
                    <td>${accessories.map(a => a.inst_type || '').join(', ')}</td>
                </tr>`;
                tableBody.innerHTML += row;

                // Store the full data object
                originalData.push(fullData);
            }

            document.getElementById('dataTable').style.display = 'block';
            document.getElementById('instructionBox').style.display = 'none';
            document.getElementById('instructionBox2').style.display = 'none';
            document.getElementById('instructionBox3').style.display = 'none';
            document.getElementById('instructionBox4').style.display = 'none';
            document.getElementById('searchInfo').style.display = 'none';

            if (!tableInitialized) {
                $('#dataTable').DataTable({
                    searching: false,
                    paging: false,
                    info: false,
                    order: [],
                    columnDefs: [
                        {
                            targets: 1,
                            orderData: [1, 2],
                        }
                    ]
                });
                tableInitialized = true;
            } else {
                $('#dataTable').DataTable().clear().rows.add($(tableBody).children()).draw();
            }

            saveState();

        } catch (error) {
            console.error("Error parsing XML file:", error);
            alert("An error occurred while processing the XML file. Please check the console for details.");
        }
    };

    reader.readAsText(file);
}


// Function to ask for show information and save it in global variables
function getShowInfo() {
    showName = prompt("Enter the name of the show:", showName || "Unnamed Show");
    designer = prompt("Enter the name of the designer:", designer || "Unknown Designer");
    headElectrician = prompt("Enter the name of the head electrician:", headElectrician || "Unknown Head Electrician");

    // Ensure variables are not empty if user clears them
    showName = showName ? showName : "Unnamed Show";
    designer = designer ? designer : "Unknown Designer";
    headElectrician = headElectrician ? headElectrician : "Unknown Head Electrician";

    saveState();
}


function searchByChannel() {
    const input = prompt("Enter a range (e.g., 1-5) or a list of channel numbers (e.g., 1,2,3):");
    if (input) {
        const filterValues = input.split(',').map(x => x.trim());
        const filteredData = originalData.filter(item => {
            const itemChannel = item.channel || item.chan || '';
            return filterValues.some(value => 
                isInChannelRange(itemChannel, value) || itemChannel === value.trim()
            );
        });

        updateTableWithFilteredData(filteredData, input);
    }
}

function isInChannelRange(channel, input) {
    if (!channel) return false;
    
    const rangePattern = /(\d+)-(\d+)/; // Regex to match ranges like 1-5
    const match = input.match(rangePattern);
    if (match) {
        const start = parseInt(match[1]);
        const end = parseInt(match[2]);
        const channelNum = parseInt(channel);
        return !isNaN(channelNum) && channelNum >= start && channelNum <= end;
    }
    return false;
}

function searchByAddress() {
    const input = prompt("Enter a range (e.g., 100-200) or a list of addresses (e.g., 100,150,200):");
    if (input) {
        const filterValues = input.split(',').map(x => x.trim());
        const filteredData = originalData.filter(item => {
            const itemAddress = item.address || item.absolute_address || '';
            return filterValues.some(value => 
                isInAddressRange(itemAddress, value) || itemAddress === value.trim()
            );
        });

        updateTableWithFilteredData(filteredData, input);
    }
}

function isInAddressRange(address, input) {
    if (!address) return false;
    
    const rangePattern = /(\d+)-(\d+)/; // Regex to match ranges like 100-200
    const match = input.match(rangePattern);
    if (match) {
        const start = parseInt(match[1]);
        const end = parseInt(match[2]);
        const addressNum = parseInt(address);
        return !isNaN(addressNum) && addressNum >= start && addressNum <= end;
    }
    return false;
}

function searchByPosition() {
    const uniquePositions = [...new Set(originalData.map(item => 
        item.position || item.pos || ''
    ).filter(Boolean))]; // Get unique positions, excluding empty values

    // Create the checkboxes dynamically
    let checkboxHTML = uniquePositions.map(position => {
        return `<label><input type="checkbox" value="${position}"> ${position}</label><br>`;
    }).join('');

    // Create a collapsible container for the checkboxes
    const collapsibleHTML = `
        <div class="collapsible-header">
            <h3>Select Positions <span class="toggle-icon">▲</span></h3>
        </div>
        <div class="collapsible-content" style="display: block;">
            ${checkboxHTML}
        </div>
    `;

    // Display the user selection box at the top
    const userSelectionBox = createSelectionBox(collapsibleHTML);
    document.body.insertBefore(userSelectionBox, document.getElementById('dataTable').parentNode);

    // Add collapsible functionality
    const header = userSelectionBox.querySelector('.collapsible-header');
    const content = userSelectionBox.querySelector('.collapsible-content');
    const toggleIcon = userSelectionBox.querySelector('.toggle-icon');

    header.addEventListener('click', () => {
        content.style.display = content.style.display === 'none' ? 'block' : 'none';
        toggleIcon.textContent = content.style.display === 'none' ? '▼' : '▲';
    });

    // Wait for the user to make their selection
    promptUserToSelectPositions(userSelectionBox, checkboxHTML).then(userSelection => {
        if (userSelection) {
            const selectedPositions = userSelection.split(',').map(position => position.trim());
            const filteredData = originalData.filter(item => {
                const itemPosition = item.position || item.pos || '';
                return selectedPositions.includes(itemPosition);
            });

            updateTableWithFilteredData(filteredData, `Positions: ${userSelection}`);
        }
    });

    // Add cancel button
    const cancelButton = document.createElement('button');
    cancelButton.textContent = 'Cancel';
    cancelButton.id = 'cancelSelection';
    cancelButton.style.marginLeft = '10px';
    userSelectionBox.querySelector('button#submitSelection').insertAdjacentElement('afterend', cancelButton);

    cancelButton.addEventListener('click', () => {
        document.body.removeChild(userSelectionBox);
    });
}

// Helper function to update table with filtered data
function updateTableWithFilteredData(filteredData, searchCriteria) {
    const tableBody = document.getElementById('tableBody');
    tableBody.innerHTML = ''; // Clear existing rows

    filteredData.forEach(item => {
        // Extract accessory types into a string
        const accessoriesText = Array.isArray(item.accessories) 
            ? item.accessories.map(acc => acc.type || acc.inst_type || "Unknown").join("; ")
            : typeof item.accessories === 'string' 
                ? item.accessories 
                : "";

        const row = `<tr>
            <td>${item.channel || item.chan || ''}</td>
            <td>${item.position || item.pos || ''}</td>
            <td>${item.unit || item.unit_number || ''}</td>
            <td>${item.purpose || ''}</td>
            <td>${item.type || item.inst_type || ''}</td>
            <td>${item.dimmer || ''}</td>
            <td>${item.address || item.absolute_address || ''}</td>
            <td>${item.color || ''}</td>
            <td>${item.gobo || item.template || ''}</td>
            <td>${accessoriesText}</td>
        </tr>`;
        tableBody.innerHTML += row;
    });

    $('#dataTable').DataTable().clear().rows.add($(tableBody).children()).draw();
    
    // Display the search criteria
    document.getElementById('searchInfo').style.display = 'block';
    document.getElementById('searchCriteria').innerText = searchCriteria;
}

function createSelectionBox(checkboxHTML) {
    const box = document.createElement('div');
    box.id = 'selectionBox';
    box.innerHTML = `
        <div>${checkboxHTML}</div>
        <button id="submitSelection">Submit</button>
    `;
    return box;
}

function promptUserToSelectPositions(userSelectionBox, checkboxHTML) {
    return new Promise((resolve) => {
        document.getElementById('submitSelection').addEventListener('click', () => {
            const selectedPositions = [...userSelectionBox.querySelectorAll('input[type="checkbox"]:checked')].map(input => input.value);
            resolve(selectedPositions.join(','));

            // Remove the selection box after submission
            document.body.removeChild(userSelectionBox);
        });
    });
}




function resetSearch() {
    const tableBody = document.getElementById('tableBody');
    tableBody.innerHTML = ''; // Clear existing rows

    // Re-add all original data entries
    originalData.forEach(item => {
        // Extract accessory types into a string
        const accessoriesText = Array.isArray(item.accessories) 
            ? item.accessories.map(acc => acc.type || acc.inst_type || "Unknown").join("; ")
            : typeof item.accessories === 'string' 
                ? item.accessories 
                : "";

        const row = `<tr>
            <td>${item.channel || item.chan || ''}</td>
            <td>${item.position || item.pos || ''}</td>
            <td>${item.unit || item.unit_number || ''}</td>
            <td>${item.purpose || ''}</td>
            <td>${item.type || item.inst_type || ''}</td>
            <td>${item.dimmer || ''}</td>
            <td>${item.address || item.absolute_address || ''}</td>
            <td>${item.color || ''}</td>
            <td>${item.gobo || item.template || ''}</td>
            <td>${accessoriesText}</td>
        </tr>`;
        tableBody.innerHTML += row;
    });

    // Redraw the DataTable
    $('#dataTable').DataTable().clear().rows.add($(tableBody).children()).draw();

    // Hide search info
    document.getElementById('searchInfo').style.display = 'none';
}


function exportChannelHookup() {
    function createTableRow(instrument) {
        // Extract accessories with more flexibility
        const accessoriesText = Array.isArray(instrument.accessories) 
            ? instrument.accessories.map(acc => acc.type || acc.inst_type || "Unknown").join("; ")
            : typeof instrument.accessories === 'string' 
                ? instrument.accessories 
                : "";

        return `<div style="display: flex; justify-content: space-between; margin-bottom: 10px; width: 100%;">
            <span style="width: 12%;">${instrument.channel || instrument.chan || ''}</span>
            <span style="width: 12%;">${instrument.position || instrument.pos || ''}</span>
            <span style="width: 12%;">${instrument.unit || instrument.unit_number || ''}</span>
            <span style="width: 12%;">${instrument.purpose || ''}</span>
            <span style="width: 12%;">${instrument.type || instrument.inst_type || ''}</span>
            <span style="width: 12%;">${instrument.address || instrument.absolute_address || ''}</span>
            <span style="width: 12%;">${instrument.color || ''}</span>
            <span style="width: 12%;">${instrument.gobo || instrument.template || ''}</span>
            <span style="width: 12%;">${accessoriesText}</span>
        </div>
        <hr style="margin: 5px 0; border: none; border-top: 1px solid #000;"/>`;
    }

    function createHeader(pageNumber) { //Data Point Add
        return `
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                <h1 style="margin: 0;">Channel Hookup ${showName}</h1>
                <div style="text-align: center; font-size: 10px;">Designer: ${designer} | HE: ${headElectrician}</div>
                <div style="text-align: right; font-size: 10px;">Page ${pageNumber}...</div>
            </div>
            <div style="font-weight: bold; display: flex; justify-content: space-between; width: 100%;">
                <span style="width: 12%;">Channel</span>
                <span style="width: 12%;">Position</span>
                <span style="width: 12%;">Unit</span>
                <span style="width: 12%;">Purpose</span>
                <span style="width: 12%;">Type</span>
                <span style="width: 12%;">Address</span>
                <span style="width: 12%;">Color</span>
                <span style="width: 12%;">Gobo</span>
                <span style="width: 12%;">Accessories</span>
            </div>
            <hr style="margin: 5px 0; border: none; border-top: 1px solid #000;"/>
        `;
    }

    function createFooter(pageNumber) {
        return `
            <div style="text-align: center; font-size: 8px; margin-top: 20px;">
                <p>This was generated using Light Rewrite Web ${version}</p>
            </div>
        `;
    }

    const data = originalData.sort((a, b) => parseInt(a.channel) - parseInt(b.channel));

    if (data.length === 0) {
        alert('No instrument data available for export.');
        return;
    }

    const pdfDiv = document.createElement('div');
    pdfDiv.style.width = '100%';
    pdfDiv.style.fontSize = '12px';

    const instrumentsPerPage = 20;
    let pageNumber = 1;

    for (let i = 0; i < data.length; i += instrumentsPerPage) {
        const chunk = data.slice(i, i + instrumentsPerPage);
        const headerContent = createHeader(pageNumber);

        let pdfContent = '';
        chunk.forEach((instrument) => {
            pdfContent += createTableRow(instrument);
        });

        const footerContent = createFooter(pageNumber);
        pdfDiv.innerHTML += headerContent + pdfContent + footerContent;

        if (i + instrumentsPerPage < data.length) {
            pdfDiv.innerHTML += '<div style="page-break-after: always;"></div>';
        }

        pageNumber++;
    }

    const pdfOptions = {
        margin:       0.5,
        filename:     `${uploadedFileName}_channel_hookup.pdf`,
        image:        { type: 'jpeg', quality: 0.98 },
        html2canvas:  { scale: 2 },
        jsPDF:        { unit: 'in', format: 'letter', orientation: 'landscape' }
    };

    html2pdf().from(pdfDiv).set(pdfOptions).save();
}

function exportInstrumentSchedule() {
    function createTableRow(instrument) {
        // Extract accessories with more flexibility
        const accessoriesText = Array.isArray(instrument.accessories) 
            ? instrument.accessories.map(acc => acc.type || acc.inst_type || "Unknown").join("; ")
            : typeof instrument.accessories === 'string' 
                ? instrument.accessories 
                : "";

        return `<div style="display: flex; justify-content: space-between; margin-bottom: 10px; width: 100%;">
            <span style="width: 12%;">${instrument.unit || instrument.unit_number || ''}</span>
            <span style="width: 12%;">${instrument.purpose || ''}</span>
            <span style="width: 12%;">${instrument.type || instrument.inst_type || ''}</span>
            <span style="width: 12%;">${instrument.channel || instrument.chan || ''}</span>
            <span style="width: 12%;">${instrument.address || instrument.absolute_address || ''}</span>
            <span style="width: 12%;">${instrument.color || ''}</span>
            <span style="width: 12%;">${instrument.gobo || instrument.template || ''}</span>
            <span style="width: 12%;">${accessoriesText}</span>
        </div>
        <hr style="margin: 5px 0; border: none; border-top: 1px solid #000;"/>`;
    }

    function createHeader(position, pageNumber) { //Data Point Add
        return `
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                <h1 style="margin: 0;">Instrument Schedule</h1>
                <div style="text-align: center; font-size: 10px;">Designer: ${designer} | HE: ${headElectrician}</div>
                <div style="text-align: right; font-size: 10px;">Page ${pageNumber}...</div>
            </div>
            <div style="text-align: left; font-size: 15px; font-weight: bold">Position: ${position}</div>
            <div style="font-weight: bold; display: flex; justify-content: space-between; width: 100%; margin-top: 10px;">
                <span style="width: 12%;">Unit</span>
                <span style="width: 12%;">Purpose</span>
                <span style="width: 12%;">Type</span>
                <span style="width: 12%;">Channel</span>
                <span style="width: 12%;">Address</span>
                <span style="width: 12%;">Color</span>
                <span style="width: 12%;">Gobo</span>
                <span style="width: 12%;">Accessories</span>
            </div>
            <hr style="margin: 5px 0; border: none; border-top: 1px solid #000;"/>
        `;
    }

    function createFooter(pageNumber) {
        return `
            <div style="text-align: center; font-size: 8px; margin-top: 20px;">
                <p>This was generated using Light Rewrite Web ${version}</p>
            </div>
        `;
    }

    const data = originalData.sort((a, b) => {
        if (a.position === b.position) {
            // Handle cases where unit might be in either unit or unit_number field
            const unitA = parseInt(a.unit || a.unit_number || '0');
            const unitB = parseInt(b.unit || b.unit_number || '0'); 
            return unitA - unitB; // Ascending order
        }
        return (a.position || '').localeCompare(b.position || '');
    });

    if (data.length === 0) {
        alert('No instrument data available for export.');
        return;
    }

    const pdfDiv = document.createElement('div');
    pdfDiv.style.width = '100%';
    pdfDiv.style.fontSize = '12px';

    const instrumentsPerPage = 14; // Limit to 15 instruments per page
    let pageNumber = 1;
    let lastPosition = ''; // Track the last position to detect changes
    let instrumentsInPosition = 0; // Track the number of instruments on the current page

    for (let i = 0; i < data.length; i++) {
        const instrument = data[i];

        // If the position is different, or we have reached the instrument limit per page, 
        // add a page break and reset the instrument count
        if (instrument.position !== lastPosition || instrumentsInPosition === instrumentsPerPage) {
            // If it's not the first position, add a page break
            if (lastPosition !== '') {
                pdfDiv.innerHTML += '<div style="page-break-after: always;"></div>';
            }

            // Add the header for the new position
            pdfDiv.innerHTML += createHeader(instrument.position, pageNumber);
            lastPosition = instrument.position; // Update last position
            instrumentsInPosition = 0; // Reset counter for instruments

            pageNumber++; // Increment page number
        }

        // Add the instrument to the page
        pdfDiv.innerHTML += createTableRow(instrument);

        // Increment instrument count for the current page
        instrumentsInPosition++;
         // If we have reached the limit for the page, insert a page break and footer
         if (instrumentsInPosition === instrumentsPerPage) {
            // Add the footer at the bottom of the page after the instruments
            pdfDiv.innerHTML += createFooter(pageNumber);
        }

        // If it's the last instrument for this position or last in data, insert the page break
        if (i === data.length - 1 || data[i + 1].position !== instrument.position) {
            const footerContent = createFooter(pageNumber);
            pdfDiv.innerHTML += footerContent;
        }
    }

    const pdfOptions = {
        margin:       0.5,
        filename:     `${uploadedFileName}_instrument_schedule.pdf`,
        image:        { type: 'jpeg', quality: 0.98 },
        html2canvas:  { scale: 2 },
        jsPDF:        { unit: 'in', format: 'letter', orientation: 'landscape' }
    };

    html2pdf().from(pdfDiv).set(pdfOptions).save();
}

function exportColorCount() {
    function createHeader(pageNumber) { //Data Point Add
        return `
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                <h1 style="margin: 0;">Color Count ${showName}</h1>
                <div style="text-align: center; font-size: 10px;">Designer: ${designer} | HE: ${headElectrician}</div>
                <div style="text-align: right; font-size: 10px;">Page ${pageNumber}...</div>
            </div>
            <div style="font-weight: bold; display: flex; justify-content: space-between; width: 100%;">
                <span style="width: 45%;">Color</span>
                <span style="width: 45%;">Instrument Type</span>
                <span style="width: 10%;">Count</span>
            </div>
            <hr style="margin: 5px 0; border: none; border-top: 1px solid #000;"/>
        `;
    }

    function createFooter(pageNumber) {
        return `
            <div style="text-align: center; font-size: 8px; margin-top: 20px;">
                <p>This was generated using Light Rewrite Web ${version}</p>
            </div>
        `;
    }

    // Create a map to count colors by instrument type (using "type" field)
    const colorCount = {};

    originalData.forEach(instrument => {
        const color = instrument.color || "Unknown";  // Default to "Unknown" if no color
        const instType = instrument.type || instrument.inst_type || "Unknown";  // Add fallback for inst_type

        // Debugging: Log the inst_type and color for each instrument
        console.log(`Instrument: ${instrument.channel}, Color: ${color}, Instrument Type: ${instType}`);

        if (!colorCount[color]) {
            colorCount[color] = {};
        }

        if (!colorCount[color][instType]) {
            colorCount[color][instType] = 0;
        }

        colorCount[color][instType]++;
    });

    // Flatten the colorCount object into an array for easy PDF generation
    const colorReport = [];
    for (const color in colorCount) {
        for (const instType in colorCount[color]) {
            colorReport.push({
                color: color,
                instType: instType,
                count: colorCount[color][instType]
            });
        }
    }

    // Sort the report alphabetically by color and instrument type
    colorReport.sort((a, b) => {
        if (a.color === b.color) {
            return a.instType.localeCompare(b.instType);
        }
        return a.color.localeCompare(b.color);
    });

    if (colorReport.length === 0) {
        alert('No color data available for export.');
        return;
    }

    const pdfDiv = document.createElement('div');
    pdfDiv.style.width = '100%';
    pdfDiv.style.fontSize = '12px';

    const itemsPerPage = 20;
    let pageNumber = 1;

    for (let i = 0; i < colorReport.length; i += itemsPerPage) {
        const chunk = colorReport.slice(i, i + itemsPerPage);
        const headerContent = createHeader(pageNumber);

        let pdfContent = '';
        chunk.forEach((report) => {
            pdfContent += `<div style="display: flex; justify-content: space-between; margin-bottom: 10px; width: 100%;">
                <span style="width: 45%;">${report.color}</span>
                <span style="width: 45%;">${report.instType}</span>
                <span style="width: 10%;">${report.count}</span>
            </div>
            <hr style="margin: 5px 0; border: none; border-top: 1px solid #000;"/>`;
        });

        const footerContent = createFooter(pageNumber);
        pdfDiv.innerHTML += headerContent + pdfContent + footerContent;

        if (i + itemsPerPage < colorReport.length) {
            pdfDiv.innerHTML += '<div style="page-break-after: always;"></div>';
        }

        pageNumber++;
    }

    const pdfOptions = {
        margin:       0.5,
        filename:     `${uploadedFileName}_color_count.pdf`,
        image:        { type: 'jpeg', quality: 0.98 },
        html2canvas:  { scale: 2 },
        jsPDF:        { unit: 'in', format: 'letter', orientation: 'landscape' }
    };

    html2pdf().from(pdfDiv).set(pdfOptions).save();
}

function exportInstrumentTypeCount() {
    function createHeader(pageNumber) {
        return `
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                <h1 style="margin: 0;">Instrument Type Count ${showName}</h1>
                <div style="text-align: center; font-size: 10px;">Designer: ${designer} | HE: ${headElectrician}</div>
                <div style="text-align: right; font-size: 10px;">Page ${pageNumber}...</div>
            </div>
            <div style="font-weight: bold; display: flex; justify-content: space-between; width: 100%;">
                <span style="width: 80%;">Instrument Type</span>
                <span style="width: 20%;">Count</span>
            </div>
            <hr style="margin: 5px 0; border: none; border-top: 1px solid #000;"/>
        `;
    }

    function createFooter(pageNumber) {
        return `
            <div style="text-align: center; font-size: 8px; margin-top: 20px;">
                <p>This was generated using Light Rewrite Web ${version}</p>
            </div>
        `;
    }

    // Create a map to count the instrument types
    const typeCount = {};

    originalData.forEach(instrument => {
        const instType = instrument.type || instrument.inst_type || "Unknown";  // Add fallback for inst_type

        // Debugging: Log the instrument type for each instrument
        console.log(`Instrument: ${instrument.channel}, Instrument Type: ${instType}`);

        if (!typeCount[instType]) {
            typeCount[instType] = 0;
        }

        typeCount[instType]++;
    });

    // Convert the typeCount object into an array for easy PDF generation
    const typeReport = [];
    for (const instType in typeCount) {
        typeReport.push({
            instType: instType,
            count: typeCount[instType]
        });
    }

    // Sort the report alphabetically by instrument type
    typeReport.sort((a, b) => a.instType.localeCompare(b.instType));

    if (typeReport.length === 0) {
        alert('No instrument type data available for export.');
        return;
    }

    const pdfDiv = document.createElement('div');
    pdfDiv.style.width = '100%';
    pdfDiv.style.fontSize = '12px';

    const itemsPerPage = 20;
    let pageNumber = 1;

    for (let i = 0; i < typeReport.length; i += itemsPerPage) {
        const chunk = typeReport.slice(i, i + itemsPerPage);
        const headerContent = createHeader(pageNumber);

        let pdfContent = '';
        chunk.forEach((report) => {
            pdfContent += `<div style="display: flex; justify-content: space-between; margin-bottom: 10px; width: 100%;">
                <span style="width: 80%;">${report.instType}</span>
                <span style="width: 20%;">${report.count}</span>
            </div>
            <hr style="margin: 5px 0; border: none; border-top: 1px solid #000;"/>`;
        });

        const footerContent = createFooter(pageNumber);
        pdfDiv.innerHTML += headerContent + pdfContent + footerContent;

        if (i + itemsPerPage < typeReport.length) {
            pdfDiv.innerHTML += '<div style="page-break-after: always;"></div>';
        }

        pageNumber++;
    }

    const pdfOptions = {
        margin:       0.5,
        filename:     `${uploadedFileName}_instrument_type_count.pdf`,
        image:        { type: 'jpeg', quality: 0.98 },
        html2canvas:  { scale: 2 },
        jsPDF:        { unit: 'in', format: 'letter', orientation: 'landscape' }
    };

    html2pdf().from(pdfDiv).set(pdfOptions).save();
}

function generatePatchFile() {
    if (!originalData || originalData.length === 0) {
        alert("No data available to generate the patch file.");
        return;
    }

    // Define the headers for the ETC EOS Patch file
    let patchFileContent = "Purpose\tChannel\tAddress\tInstrument Type\tDevice Type\n";

    // Populate each row based on the parsed instrument data
    for (const instrument of originalData) {
        const purpose = instrument.purpose || "N/A";
        const channel = instrument.channel || instrument.chan || "N/A";
        const address = instrument.address || instrument.absolute_address || "N/A";
        const instType = instrument.type || instrument.inst_type || "N/A";
        const deviceType = "Light"; // Static value as per example output

        // Append each row to the content
        patchFileContent += `${purpose}\t${channel}\t${address}\t${instType}\t${deviceType}\n`;
    }

    // Create a blob and download the file
    const blob = new Blob([patchFileContent], { type: "text/plain" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = `${uploadedFileName}_Patch.txt`;
    link.click();
}

function populateAddressFromDimmer() {
    if (!originalData || originalData.length === 0) {
        alert("No data available to populate addresses.");
        return;
    }

    // Prompt the user to input the starting universe for dimmer 1
    let startingUniverse = parseInt(prompt("Enter the starting universe for dimmer 1:", "1"), 10);
    if (isNaN(startingUniverse) || startingUniverse < 1) {
        alert("Invalid universe number. Please enter a valid number starting from 1.");
        return;
    }

    // Loop through each instrument and assign dimmer value to address if address is empty or 0
    for (const instrument of originalData) {
        if ((!instrument.address || instrument.address === "0") && instrument.dimmer) {
            const dimmerValue = parseInt(instrument.dimmer, 10);

            if (!isNaN(dimmerValue) && dimmerValue > 0) {
                // Calculate the correct address using the formula
                const address = dimmerValue + ((startingUniverse - 1) * 512);
                instrument.address = address.toString();
            }
        }
    }
    resetSearch()
}

function exportTableToCSV() {
    // Initialize CSV content with headers
    let csvContent = "Channel,Position,Unit,Purpose,Type,Dimmer,Address,Color,Gobo,Accessories\n";

    // Iterate through each instrument in originalData
    for (const instrument of originalData) {
        let row = [
            instrument.channel || instrument.chan || '',  // Handle alternate header names
            instrument.position || instrument.pos || '',
            instrument.unit || instrument.unit_number || '',
            instrument.purpose || '',
            instrument.type || instrument.inst_type || '',
            instrument.dimmer || '',
            instrument.address || instrument.absolute_address || '',
            instrument.color || '',
            instrument.gobo || instrument.template || '',
        ];

        // Handle accessories with more flexibility
        let accessories = '';
        if (Array.isArray(instrument.accessories)) {
            accessories = instrument.accessories
                .map(acc => acc.type || acc.inst_type || '')
                .filter(Boolean)
                .join('|');
        } else if (typeof instrument.accessories === 'string') {
            accessories = instrument.accessories;
        }
        row.push(accessories);

        // Escape fields and join into a CSV row
        csvContent += row.map(field => `"${(field + '').replace(/"/g, '""')}"`).join(',') + '\n';
    }

    // Create and trigger download
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.setAttribute('download', `${uploadedFileName}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

///Work Notes
// Function to create the table and handle auto-fill functionality
function createSpreadsheet() {
    // Hide the original DataTable
    document.getElementById('dataTable').style.display = 'none';
    
    // If work notes container already exists, just show it
    if (workNotesContainer) {
        workNotesContainer.style.display = 'block';
        return;
    }

    // Create a container for the table
    workNotesContainer = document.createElement('div');
    workNotesContainer.id = 'workNotesTable';
    workNotesContainer.style.overflowX = 'auto';
    document.body.appendChild(workNotesContainer);

    // Create the table element
    const table = document.createElement('table');
    table.style.width = '100%';
    table.style.borderCollapse = 'collapse';
    
    // Keep track of sort state
    const sortState = {
        column: null,
        ascending: true
    };

    // Create the header row
    const headerRow = document.createElement('tr');
    workNoteHeaders.forEach(header => {
        const th = document.createElement('th');
        th.innerText = header;
        th.style.border = '1px solid black';
        th.style.padding = '8px';
        th.style.backgroundColor = '#f2f2f2';
        th.style.cursor = 'pointer';
        
        // Set specific widths for columns
        if (header === 'Channel') {
            th.style.width = '60px';  // Adjust this value as needed
        } else if (header === 'Notes') {
            th.style.width = '200px'; // Optional: make Notes column wider
        }
        
        // Add click event for sorting
        th.addEventListener('click', () => {
            sortTable(header, table);
        });
        
        headerRow.appendChild(th);
    });
    table.appendChild(headerRow);

    // Add a single row with an input field for the channel
    addInputRow(table);

    // Append table to container
    workNotesContainer.appendChild(table);

    function sortTable(header, table) {
        // Get all rows except header and input row
        const rows = Array.from(table.rows).slice(1, -1);
        const inputRow = table.rows[table.rows.length - 1];
        
        // Determine column index
        const columnIndex = workNoteHeaders.indexOf(header);
        
        // Update sort state
        if (sortState.column === header) {
            sortState.ascending = !sortState.ascending;
        } else {
            sortState.column = header;
            sortState.ascending = true;
        }

        // Sort rows
        rows.sort((a, b) => {
            let aValue = a.cells[columnIndex].textContent;
            let bValue = b.cells[columnIndex].textContent;

            // Handle numeric sorting for Channel, Unit, Dimmer, and Address
            if (['Channel', 'Unit', 'Dimmer', 'Address'].includes(header)) {
                aValue = parseInt(aValue) || 0;
                bValue = parseInt(bValue) || 0;
                return sortState.ascending ? aValue - bValue : bValue - aValue;
            }

            // String comparison for other columns
            return sortState.ascending ? 
                aValue.localeCompare(bValue) : 
                bValue.localeCompare(aValue);
        });

        // Remove existing rows except header and input
        while (table.rows.length > 2) {
            table.deleteRow(1);
        }

        // Add sorted rows back
        rows.forEach(row => {
            table.insertBefore(row, inputRow);
        });
    }

    function addInputRow(table) {
        const row = document.createElement('tr');
        const cell = document.createElement('td');
        cell.colSpan = workNoteHeaders.length;
        cell.style.padding = '10px';
        cell.style.display = 'flex';
        cell.style.gap = '10px';

        // Create select for input type
        const select = document.createElement('select');
        select.style.width = '100px';
        const options = ['Channel', 'Address', 'Dimmer', 'Color'];
        options.forEach(opt => {
            const option = document.createElement('option');
            option.value = opt.toLowerCase();
            option.textContent = opt;
            select.appendChild(option);
        });

        // Create input for search value
        const input = document.createElement('input');
        input.type = 'text';
        input.style.width = '100px';
        input.placeholder = 'Enter value';

        // Create input for notes
        const notesInput = document.createElement('input');
        notesInput.type = 'text';
        notesInput.style.width = '200px';
        notesInput.placeholder = 'Enter notes';

        // Create button to add row
        const button = document.createElement('button');
        button.textContent = 'Add Row';
        button.onclick = () => {
            const searchValue = input.value.trim();
            const notes = notesInput.value.trim();
            if (!searchValue) return;

            // Find matching instruments
            const matchingInstruments = originalData.filter(instrument => {
                const searchField = select.value;
                const instrumentValue = 
                    searchField === 'channel' ? (instrument.channel || instrument.chan || '') :
                    searchField === 'address' ? (instrument.address || instrument.absolute_address || '') :
                    searchField === 'dimmer' ? (instrument.dimmer || '') :
                    searchField === 'color' ? (instrument.color || '') : '';
                
                return instrumentValue.toString() === searchValue;
            });

            matchingInstruments.forEach(instrument => {
                const newRow = document.createElement('tr');
                workNoteHeaders.forEach(header => {
                    const td = document.createElement('td');
                    td.style.border = '1px solid black';
                    td.style.padding = '8px';

                    if (header === 'Notes') {
                        td.textContent = notes;
                    } else if (header === 'Delete') {
                        // Create delete button
                        const deleteButton = document.createElement('button');
                        deleteButton.innerHTML = '×';
                        deleteButton.style.cursor = 'pointer';
                        deleteButton.style.border = 'none';
                        deleteButton.style.background = 'none';
                        deleteButton.style.color = 'red';
                        deleteButton.style.fontSize = '20px';
                        deleteButton.style.padding = '0';
                        deleteButton.title = 'Delete Row';
                        
                        deleteButton.onclick = function() {
                            newRow.remove();
                            saveState();
                        };
                        
                        td.style.width = '30px';
                        td.style.textAlign = 'center';
                        td.appendChild(deleteButton);
                    } else {
                        // Handle different field names and accessories
                        let value = '';
                        switch(header.toLowerCase()) {
                            case 'channel':
                                value = instrument.channel || instrument.chan || '';
                                break;
                            case 'position':
                                value = instrument.position || instrument.pos || '';
                                break;
                            case 'unit':
                                value = instrument.unit || instrument.unit_number || '';
                                break;
                            case 'purpose':
                                value = instrument.purpose || '';
                                break;
                            case 'type':
                                value = instrument.type || instrument.inst_type || '';
                                break;
                            case 'dimmer':
                                value = instrument.dimmer || '';
                                break;
                            case 'address':
                                value = instrument.address || instrument.absolute_address || '';
                                break;
                            case 'color':
                                value = instrument.color || '';
                                break;
                            case 'gobo':
                                value = instrument.gobo || instrument.template || '';
                                break;
                            case 'accessories':
                                value = Array.isArray(instrument.accessories) 
                                    ? instrument.accessories.map(acc => acc.type || acc.inst_type || "Unknown").join("; ")
                                    : typeof instrument.accessories === 'string' 
                                        ? instrument.accessories 
                                        : "";
                                break;
                        }
                        td.textContent = value;
                    }
                    newRow.appendChild(td);
                });
                table.insertBefore(newRow, row);
            });

            // Clear inputs after adding
            input.value = '';
            notesInput.value = '';
        };

        cell.appendChild(select);
        cell.appendChild(input);
        cell.appendChild(notesInput);
        cell.appendChild(button);
        row.appendChild(cell);
        table.appendChild(row);
    }

    function handleInput(inputValue, searchType, notes) {
        let matchingData = [];

        switch(searchType) {
            case 'channel':
                matchingData = originalData.filter(item => item.channel === inputValue);
                break;
            case 'address':
                matchingData = originalData.filter(item => item.address === inputValue);
                break;
            case 'dimmer':
                matchingData = originalData.filter(item => item.dimmer === inputValue);
                break;
            case 'color':
                matchingData = originalData.filter(item => 
                    item.color && item.color.toLowerCase().includes(inputValue.toLowerCase())
                );
                break;
        }

        if (matchingData.length > 0) {
            matchingData.forEach(rowData => {
                const row = document.createElement('tr');
                
                // Add all data cells first
                workNoteHeaders.forEach(header => {
                    const cell = document.createElement('td');
                    cell.style.border = '1px solid black';
                    cell.style.padding = '8px';
                    
                    if (header === 'Delete') {
                        // Create delete button
                        const deleteButton = document.createElement('button');
                        deleteButton.innerHTML = '×';
                        deleteButton.style.cursor = 'pointer';
                        deleteButton.style.border = 'none';
                        deleteButton.style.background = 'none';
                        deleteButton.style.color = 'red';
                        deleteButton.style.fontSize = '20px';
                        deleteButton.style.padding = '0';
                        deleteButton.title = 'Delete Row';
                        
                        deleteButton.onclick = function() {
                            row.remove();
                            saveState();
                        };
                        
                        cell.style.width = '30px';
                        cell.style.textAlign = 'center';
                        cell.appendChild(deleteButton);
                    } else if (header === 'Notes') {
                        cell.innerText = notes || '';
                    } else if (header === 'Accessories' && Array.isArray(rowData.accessories)) {
                        cell.innerText = rowData.accessories.map(acc => acc.type).join(', ') || '';
                    } else {
                        cell.innerText = rowData[header.toLowerCase()] || '';
                    }
                    
                    row.appendChild(cell);
                });
                
                // Add delete row button
                const deleteRowCell = document.createElement('td');
                const deleteRowButton = document.createElement('button');
                deleteRowButton.innerHTML = 'Delete Row';
                deleteRowButton.style.cursor = 'pointer';
                deleteRowButton.onclick = function() {
                    row.remove();
                    saveState();
                };
                deleteRowCell.appendChild(deleteRowButton);
                row.appendChild(deleteRowCell);
                
                table.insertBefore(row, table.lastElementChild);
            });
        } else {
            alert(`No fixture found with ${searchType} ${inputValue}`);
        }
    }

    // Add saveState() calls after table modifications
    const originalHandleInput = handleInput;
    handleInput = function(...args) {
        originalHandleInput.apply(this, args);
        saveState();
    };
}

function showMainView() {
    // Show the original table
    document.getElementById('dataTable').style.display = 'block';
    
    // Hide work notes if they exist
    if (workNotesContainer) {
        workNotesContainer.style.display = 'none';
    }
    
    // Hide all columns view if it exists
    const allColumnsView = document.getElementById('allColumnsView');
    if (allColumnsView) {
        // Properly destroy the DataTable instance first
        const dynamicTable = $('#dynamicTable');
        if ($.fn.DataTable.isDataTable(dynamicTable)) {
            dynamicTable.DataTable().destroy();
        }
        // Remove the element from the DOM
        allColumnsView.remove();
    }
}

function exportWorkNotes() {
    if (!workNotesContainer || workNotesContainer.style.display === 'none') {
        alert('No work notes available to export.');
        return;
    }

    const rows = Array.from(workNotesContainer.querySelectorAll('tr')).slice(1, -1); // Skip header and input row
    if (rows.length === 0) {
        alert('No work notes to export.');
        return;
    }

    function createHeader(pageNumber) {
        return `
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                <h1 style="margin: 0;">Work Notes ${showName}</h1>
                <div style="text-align: center; font-size: 10px;">Designer: ${designer} | HE: ${headElectrician}</div>
                <div style="text-align: right; font-size: 10px;">Page ${pageNumber}...</div>
            </div>
            <div style="font-weight: bold; display: flex; justify-content: space-between; width: 100%;">
                ${workNoteHeaders.map(header => 
                    `<span style="width: ${header === 'Notes' ? '20%' : '8%'};">${header}</span>`
                ).join('')}
            </div>
            <hr style="margin: 5px 0; border: none; border-top: 1px solid #000;"/>
        `;
    }

    // Rest of exportWorkNotes function remains the same...
}

function clearStoredData() {
    if (confirm('Are you sure you want to clear all stored data? This cannot be undone.')) {
        // Clear localStorage
        localStorage.removeItem('lightRewriteState');
        
        // Reset all global variables
        originalData = [];
        tableInitialized = false;
        instrumentData = [];
        uploadedFileName = '';
        showName = '';
        designer = '';
        headElectrician = '';
        
        // Clear work notes if they exist
        if (workNotesContainer) {
            workNotesContainer.remove();
            workNotesContainer = null;
        }

        // Reset table display
        document.getElementById('dataTable').style.display = 'none';
        document.getElementById('instructionBox').style.display = 'block';
        document.getElementById('instructionBox2').style.display = 'block';
        document.getElementById('instructionBox3').style.display = 'block';
        document.getElementById('instructionBox4').style.display = 'block';
        document.getElementById('searchInfo').style.display = 'none';
        
        // Clear the table body
        document.getElementById('tableBody').innerHTML = '';
        
        // Destroy and reset DataTable if it exists
        if ($.fn.DataTable.isDataTable('#dataTable')) {
            $('#dataTable').DataTable().destroy();
        }
        
        // Reload the page to ensure a clean state
        location.reload();
    }
}

function processCSVFile() {
    const fileInput = document.getElementById('csvFileInput');
    const file = fileInput.files[0];
    if (!file) {
        alert('Please select a CSV file.');
        return;
    }

    // Store the uploaded file name (without the extension) for later use
    uploadedFileName = file.name.replace(/\.[^/.]+$/, ""); // Remove file extension

    const reader = new FileReader();
    reader.onload = function(event) {
        try {
            // Split the CSV content into lines
            const lines = event.target.result.split('\n');
            
            // Get all headers from first line and clean them
            const allHeaders = lines[0].split(',').map(header => 
                header.trim().replace(/^["']|["']$/g, '').toLowerCase()
            );

            const tableBody = document.getElementById('tableBody');
            tableBody.innerHTML = '';
            originalData = [];

            // Process each line (skip header)
            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;

                // Split the line into values and clean them
                const values = lines[i].split(',').map(value => 
                    value.trim().replace(/^["']|["']$/g, '')
                );

                // Create data object with ALL headers
                const fullData = {};
                allHeaders.forEach((header, index) => {
                    fullData[header] = values[index] || '';
                });

                // Parse accessories if present
                const accessories = fullData.accessories ? 
                    fullData.accessories.split(';').map(acc => ({
                        type: acc.trim()
                    })) : [];
                fullData.accessories = accessories;

                // Create table row with only expected columns
                const row = `<tr> 
                    <td>${fullData.channel || ''}</td>
                    <td>${fullData.position || ''}</td>
                    <td>${fullData.unit || ''}</td>
                    <td>${fullData.purpose || ''}</td>
                    <td>${fullData.type || ''}</td>
                    <td>${fullData.dimmer || ''}</td>
                    <td>${fullData.address || ''}</td>
                    <td>${fullData.color || ''}</td>
                    <td>${fullData.gobo || ''}</td>
                    <td>${accessories.map(a => a.type || '').join(', ')}</td>
                </tr>`;
                tableBody.innerHTML += row;

                // Store the full data object
                originalData.push(fullData);
            }

            // Update UI
            document.getElementById('dataTable').style.display = 'block';
            document.getElementById('instructionBox').style.display = 'none';
            document.getElementById('instructionBox2').style.display = 'none';
            document.getElementById('instructionBox3').style.display = 'none';
            document.getElementById('instructionBox4').style.display = 'none';
            document.getElementById('searchInfo').style.display = 'none';

            // Initialize or update DataTable
            if (!tableInitialized) {
                $('#dataTable').DataTable({
                    searching: false,
                    paging: false,
                    info: false,
                    order: [],
                    columnDefs: [{
                        targets: 1,
                        orderData: [1, 2],
                    }]
                });
                tableInitialized = true;
            } else {
                $('#dataTable').DataTable().clear().rows.add($(tableBody).children()).draw();
            }

            saveState();

        } catch (error) {
            console.error("Error parsing CSV file:", error);
            alert("An error occurred while processing the CSV file. Please check the console for details.");
        }
    };

    reader.readAsText(file);
}

function processXLSXFile() {
    const fileInput = document.getElementById('xlsxFileInput');
    const file = fileInput.files[0];
    if (!file) {
        alert('Please select an Excel file.');
        return;
    }

    // Store the uploaded file name (without the extension) for later use
    uploadedFileName = file.name.replace(/\.[^/.]+$/, ""); // Remove file extension

    const reader = new FileReader();
    reader.onload = function(event) {
        try {
            const data = new Uint8Array(event.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            const worksheet = workbook.Sheets[workbook.SheetNames[0]];
            const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

            if (jsonData.length === 0) {
                alert('No data found in the Excel file.');
                return;
            }

            // Get all headers from first row
            const allHeaders = jsonData[0].map(header => 
                String(header).trim().toLowerCase()
            );

            const tableBody = document.getElementById('tableBody');
            tableBody.innerHTML = '';
            originalData = [];

            // Process each row (skip header)
            for (let i = 1; i < jsonData.length; i++) {
                const values = jsonData[i];
                if (!values || values.length === 0) continue;

                // Create data object with ALL headers
                const fullData = {};
                allHeaders.forEach((header, index) => {
                    fullData[header] = values[index] ? String(values[index]).trim() : '';
                });

                // Parse accessories if present
                const accessories = fullData.accessories ? 
                    String(fullData.accessories).split(';').map(acc => ({
                        type: acc.trim()
                    })) : [];
                fullData.accessories = accessories;

                // Create table row with only expected columns
                const row = `<tr> 
                    <td>${fullData.channel || ''}</td>
                    <td>${fullData.position || ''}</td>
                    <td>${fullData.unit || ''}</td>
                    <td>${fullData.purpose || ''}</td>
                    <td>${fullData.type || ''}</td>
                    <td>${fullData.dimmer || ''}</td>
                    <td>${fullData.address || ''}</td>
                    <td>${fullData.color || ''}</td>
                    <td>${fullData.gobo || ''}</td>
                    <td>${accessories.map(a => a.type || '').join(', ')}</td>
                </tr>`;
                tableBody.innerHTML += row;

                // Store the full data object
                originalData.push(fullData);
            }

            // Update UI
            document.getElementById('dataTable').style.display = 'block';
            document.getElementById('instructionBox').style.display = 'none';
            document.getElementById('instructionBox2').style.display = 'none';
            document.getElementById('instructionBox3').style.display = 'none';
            document.getElementById('instructionBox4').style.display = 'none';
            document.getElementById('searchInfo').style.display = 'none';

            // Initialize or update DataTable
            if (!tableInitialized) {
                $('#dataTable').DataTable({
                    searching: false,
                    paging: false,
                    info: false,
                    order: [],
                    columnDefs: [{
                        targets: 1,
                        orderData: [1, 2],
                    }]
                });
                tableInitialized = true;
            } else {
                $('#dataTable').DataTable().clear().rows.add($(tableBody).children()).draw();
            }

            saveState();

        } catch (error) {
            console.error("Error parsing Excel file:", error);
            alert("An error occurred while processing the Excel file. Please check the console for details.");
        }
    };

    reader.readAsArrayBuffer(file);
}

// Add event listener for page load
window.addEventListener('load', () => {
    loadState();
});

// Add event listener for before page unload
window.addEventListener('beforeunload', () => {
    saveState();
});

function compareCSVWithOriginal() {
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.csv, .xlsx';
    
    fileInput.onchange = function(e) {
        const file = e.target.files[0];
        if (!file) {
            alert('Please select a CSV or Excel file.');
            return;
        }

        if (file.name.endsWith('.csv')) {
            processCSVComparison(file);
        } else if (file.name.endsWith('.xlsx')) {
            processExcelComparison(file);
        } else {
            alert('Unsupported file type. Please select a CSV or Excel file.');
        }
    };

    fileInput.click();
}

function processCSVComparison(file) {
    const reader = new FileReader();
    reader.onload = function(event) {
        try {
            const comparisonData = parseCSV(event.target.result);
            compareDifferences(comparisonData);
        } catch (error) {
            console.error("Error comparing CSV file:", error);
            alert("An error occurred while comparing the CSV file. Please check the console for details.");
        }
    };
    reader.readAsText(file);
}

function processExcelComparison(file) {
    const reader = new FileReader();
    reader.onload = function(event) {
        try {
            const data = new Uint8Array(event.target.result);
            const workbook = XLSX.read(data, {type: 'array'});
            const firstSheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[firstSheetName];
            const comparisonData = XLSX.utils.sheet_to_json(worksheet, {header: 1});
            compareDifferences(parseExcel(comparisonData));
        } catch (error) {
            console.error("Error comparing Excel file:", error);
            alert("An error occurred while comparing the Excel file. Please check the console for details.");
        }
    };
    reader.readAsArrayBuffer(file);
}

function parseCSV(csvContent) {
    const lines = csvContent.split('\n');
    const headers = lines[0].split(',').map(header => 
        header.trim().replace(/^["']|["']$/g, '').toLowerCase()
    );
    
    // Convert CSV lines to arrays of values, handling quoted values correctly
    const rows = lines.slice(1).map(line => {
        const values = [];
        let inQuotes = false;
        let currentValue = '';
        
        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            
            if (char === '"') {
                inQuotes = !inQuotes;
            } else if (char === ',' && !inQuotes) {
                values.push(currentValue.trim());
                currentValue = '';
            } else {
                currentValue += char;
            }
        }
        values.push(currentValue.trim()); // Push the last value
        
        return values;
    });

    return parseFileContent(rows, headers);
}

function parseExcel(excelData) {
    const headers = excelData[0].map(header => header.toLowerCase());
    return parseFileContent(excelData.slice(1), headers);
}

function parseFileContent(dataRows, headers) {
    const requiredHeaders = ['channel', 'position', 'unit', 'purpose', 'type', 'dimmer', 'address', 'color', 'gobo', 'accessories'];
    const missingHeaders = requiredHeaders.filter(h => !headers.includes(h));
    
    if (missingHeaders.length > 0) {
        throw new Error(`Missing required headers: ${missingHeaders.join(', ')}`);
    }

    // Filter out empty rows and convert all values to strings
    return dataRows
        .filter(row => Array.isArray(row) && row.some(cell => {
            // Convert to string if possible, otherwise use empty string
            const cellValue = (cell != null) ? String(cell) : '';
            return cellValue.trim() !== '';
        }))
        .map(row => {
            const rowData = {};
            headers.forEach((header, index) => {
                // Convert cell value to string, handling null/undefined
                const cellValue = (row[index] != null) ? String(row[index]) : '';
                rowData[header] = cellValue.trim();
            });
            return rowData;
        });
}

function compareDifferences(comparisonData) {
    const differences = {
        original: [],
        comparison: []
    };

    originalData.forEach(originalRow => {
        const matchingRow = comparisonData.find(compRow => 
            compRow.channel === originalRow.channel &&
            compRow.position === originalRow.position &&
            compRow.unit === originalRow.unit
        );

        if (!matchingRow || hasDifferences(originalRow, matchingRow)) {
            differences.original.push(originalRow);
        }
    });

    comparisonData.forEach(compRow => {
        const matchingRow = originalData.find(origRow => 
            origRow.channel === compRow.channel &&
            origRow.position === compRow.position &&
            origRow.unit === compRow.unit
        );

        if (!matchingRow || hasDifferences(compRow, matchingRow)) {
            differences.comparison.push(compRow);
        }
    });

    displayDifferences(differences);
}

function hasDifferences(row1, row2) {
    const compareFields = ['purpose', 'type', 'dimmer', 'address', 'color', 'gobo', 'accessories'];
    return compareFields.some(field => {
        if (field === 'accessories') {
            const acc1 = Array.isArray(row1.accessories) ? 
                row1.accessories.map(a => a.type).join(';') : row1.accessories;
            const acc2 = Array.isArray(row2.accessories) ? 
                row2.accessories.map(a => a.type).join(';') : row2.accessories;
            return acc1 !== acc2;
        }
        return row1[field] !== row2[field];
    });
}

function displayDifferences(differences) {
    // Create a modal overlay
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: flex-start;
        overflow-y: auto;
        z-index: 1000;
    `;

    // Create the content container
    const content = document.createElement('div');
    content.style.cssText = `
        background: white;
        padding: 20px;
        margin: 20px;
        border-radius: 8px;
        max-width: 95%;
        max-height: 90vh;
        overflow-y: auto;
        position: relative;
    `;

    // Add close and save buttons
    const buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = `
        position: sticky;
        top: 0;
        right: 0;
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        background: white;
        padding: 5px;
        z-index: 2;
    `;

    const saveButton = document.createElement('button');
    saveButton.innerHTML = 'Update';
    saveButton.style.cssText = `
        padding: 5px 10px;
        background: #4CAF50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
    `;

    const closeButton = document.createElement('button');
    closeButton.innerHTML = '×';
    closeButton.style.cssText = `
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        padding: 5px;
    `;

    buttonContainer.appendChild(saveButton);
    buttonContainer.appendChild(closeButton);

    // Create arrays to store selected rows
    const selectedRows = new Map();

    // Create the content HTML
    content.innerHTML = `
        <style>
            .diff-table { 
                width: 100%; 
                border-collapse: collapse; 
                margin-bottom: 20px; 
            }
            .diff-table th, .diff-table td { 
                border: 1px solid #ddd; 
                padding: 8px; 
                text-align: left; 
            }
            .diff-table th { 
                background-color: #f2f2f2; 
                position: sticky;
                top: 40px;
                z-index: 1;
            }
            .diff-section { 
                margin-bottom: 30px; 
            }
            h1, h2 { 
                color: #333; 
            }
            .original { 
                background-color: #ffe6e6; 
            }
            .comparison { 
                background-color: #e6ffe6; 
            }
            .selected {
                outline: 2px solid #4CAF50;
            }
            .row-select {
                cursor: pointer;
            }
            .row-select:hover {
                background-color: #f5f5f5;
            }
        </style>
        <h1>Data Comparison Results</h1>
        <p>Click on a row to select which version you want to keep. Selected rows will have a green outline.</p>
        
        <div class="diff-section">
            <h2>Original Data Differences (${differences.original.length} items)</h2>
            <table class="diff-table original">
                <tr>
                    <th>Channel</th>
                    <th>Position</th>
                    <th>Unit</th>
                    <th>Purpose</th>
                    <th>Type</th>
                    <th>Dimmer</th>
                    <th>Address</th>
                    <th>Color</th>
                    <th>Gobo</th>
                    <th>Accessories</th>
                </tr>
                ${differences.original.map((row, index) => `
                    <tr class="row-select" data-type="original" data-index="${index}">
                        <td>${row.channel || ''}</td>
                        <td>${row.position || ''}</td>
                        <td>${row.unit || ''}</td>
                        <td>${row.purpose || ''}</td>
                        <td>${row.type || ''}</td>
                        <td>${row.dimmer || ''}</td>
                        <td>${row.address || ''}</td>
                        <td>${row.color || ''}</td>
                        <td>${row.gobo || ''}</td>
                        <td>${Array.isArray(row.accessories) ? 
                            row.accessories.map(a => a.type).join(', ') : 
                            row.accessories || ''}</td>
                    </tr>
                `).join('')}
            </table>
        </div>

        <div class="diff-section">
            <h2>Comparison Data Differences (${differences.comparison.length} items)</h2>
            <table class="diff-table comparison">
                <tr>
                    <th>Channel</th>
                    <th>Position</th>
                    <th>Unit</th>
                    <th>Purpose</th>
                    <th>Type</th>
                    <th>Dimmer</th>
                    <th>Address</th>
                    <th>Color</th>
                    <th>Gobo</th>
                    <th>Accessories</th>
                </tr>
                ${differences.comparison.map((row, index) => `
                    <tr class="row-select" data-type="comparison" data-index="${index}">
                        <td>${row.channel || ''}</td>
                        <td>${row.position || ''}</td>
                        <td>${row.unit || ''}</td>
                        <td>${row.purpose || ''}</td>
                        <td>${row.type || ''}</td>
                        <td>${row.dimmer || ''}</td>
                        <td>${row.address || ''}</td>
                        <td>${row.color || ''}</td>
                        <td>${row.gobo || ''}</td>
                        <td>${row.accessories || ''}</td>
                    </tr>
                `).join('')}
            </table>
        </div>
    `;

    // Add event listeners for row selection
    content.addEventListener('click', (e) => {
        const row = e.target.closest('.row-select');
        if (row) {
            const type = row.dataset.type;
            const index = parseInt(row.dataset.index);
            const key = `${type}-${index}`;
            
            // Toggle selection
            if (selectedRows.has(key)) {
                selectedRows.delete(key);
                row.classList.remove('selected');
            } else {
                // Find matching row in other table and deselect it
                const matchingData = type === 'original' ? 
                    differences.comparison[index] : differences.original[index];
                if (matchingData) {
                    const matchingKey = `${type === 'original' ? 'comparison' : 'original'}-${index}`;
                    selectedRows.delete(matchingKey);
                    const matchingRow = content.querySelector(`[data-type="${type === 'original' ? 'comparison' : 'original'}"][data-index="${index}"]`);
                    if (matchingRow) matchingRow.classList.remove('selected');
                }
                selectedRows.set(key, { type, index });
                row.classList.add('selected');
            }
        }
    });

    // Add save functionality
    saveButton.onclick = () => {
        // Update original data based on selections
        selectedRows.forEach(({ type, index }) => {
            const selectedData = type === 'original' ? 
                differences.original[index] : 
                differences.comparison[index];

            // Find the index in originalData to update
            const originalIndex = originalData.findIndex(item => 
                item.channel === selectedData.channel &&
                item.position === selectedData.position &&
                item.unit === selectedData.unit
            );

            if (originalIndex !== -1) {
                // Update existing row
                originalData[originalIndex] = { ...selectedData };
            } else {
                // Add new row
                originalData.push({ ...selectedData });
            }
        });

        // Close modal
        document.body.removeChild(modal);
        
        // Update the original table
        updateOriginalTable();
    };

    // Add close functionality
    closeButton.onclick = () => document.body.removeChild(modal);

    // Add close on outside click
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            document.body.removeChild(modal);
        }
    });

    // Add buttons and content to modal
    content.insertBefore(buttonContainer, content.firstChild);
    modal.appendChild(content);

    // Add modal to page
    document.body.appendChild(modal);
}

function updateOriginalTable() {
    const tableBody = document.getElementById('tableBody');
    tableBody.innerHTML = ''; // Clear existing rows

    // Populate the table with updated data
    originalData.forEach(row => {
        const newRow = document.createElement('tr');
        newRow.innerHTML = `
            <td>${row.channel || ''}</td>
            <td>${row.position || ''}</td>
            <td>${row.unit || ''}</td>
            <td>${row.purpose || ''}</td>
            <td>${row.type || ''}</td>
            <td>${row.dimmer || ''}</td>
            <td>${row.address || ''}</td>
            <td>${row.color || ''}</td>
            <td>${row.gobo || ''}</td>
            <td>${Array.isArray(row.accessories) ? 
                row.accessories.map(a => a.type).join(', ') : 
                row.accessories || ''}</td>
        `;
        tableBody.appendChild(newRow);
    });

    // Refresh DataTable
    if ($.fn.DataTable.isDataTable('#dataTable')) {
        $('#dataTable').DataTable().destroy();
    }
    $('#dataTable').DataTable({
        searching: false,
        paging: false,
        info: false,
        order: [],
        columnDefs: [{
            targets: 1,
            orderData: [1, 2],
        }]
    });

    // Save state
    saveState();
}

// Add this new function
function showAllColumnsView() {
    // Check for existing view first
    let existingView = document.getElementById('allColumnsView');
    if (existingView) {
        existingView.remove(); // Remove existing view if it exists
    }

    // Hide other views
    document.getElementById('dataTable').style.display = 'none';
    if (workNotesContainer) {
        workNotesContainer.style.display = 'none';
    }

    // Get headers and sort them alphabetically
    const headers = Object.keys(originalData[0]).sort((a, b) => 
        a.toLowerCase().localeCompare(b.toLowerCase())
    );
    
    // Create container
    const container = document.createElement('div');
    container.id = 'allColumnsView';  // Add this specific ID
    container.style.cssText = `
        padding: 20px;
        margin: 20px;
        background: #f5f5f5;
        border-radius: 8px;
        font-family: Arial, sans-serif;
    `;

    // Create collapsible header
    const headerDiv = document.createElement('div');
    headerDiv.style.cssText = `
        display: flex;
        align-items: center;
        cursor: pointer;
        padding: 10px;
        background: #e0e0e0;
        border-radius: 4px;
        margin-bottom: 10px;
    `;

    const collapseIcon = document.createElement('span');
    collapseIcon.textContent = '▼';
    collapseIcon.style.marginRight = '10px';
    collapseIcon.style.transition = 'transform 0.3s';
    collapseIcon.style.transform = 'rotate(-90deg)'; // Start rotated

    const title = document.createElement('h2');
    title.textContent = "Available Columns";
    title.style.margin = '0';

    headerDiv.appendChild(collapseIcon);
    headerDiv.appendChild(title);

    // Create list
    const list = document.createElement('ul');
    list.style.cssText = `
        list-style: none;
        padding: 0;
        margin: 0;
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease-out;
    `;

    // Create table container
    const tableContainer = document.createElement('div');
    tableContainer.style.marginTop = '20px';
    tableContainer.style.overflowX = 'auto';

    // Create table
    const table = document.createElement('table');
    table.id = 'dynamicTable';
    table.style.width = '100%';
    table.style.borderCollapse = 'collapse';
    table.className = 'display';

    let dataTable; // Will hold our DataTable instance

    // Function to update table based on checkbox states
    function updateTable() {
        // Properly destroy existing DataTable if it exists
        if ($.fn.DataTable.isDataTable('#dynamicTable')) {
            $('#dynamicTable').DataTable().destroy();
        }
        table.innerHTML = ''; // Clear existing table content

        // Get checked headers
        const checkedBoxes = Array.from(list.querySelectorAll('input:checked'));
        const visibleHeaders = checkedBoxes.map(cb => cb.dataset.header);

        if (visibleHeaders.length === 0) {
            table.innerHTML = '<tr><td>No columns selected</td></tr>';
            return;
        }

        // Create header row
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        visibleHeaders.forEach(header => {
            const th = document.createElement('th');
            th.textContent = header;
            th.style.padding = '8px';
            th.style.border = '1px solid #ddd';
            headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);

        // Create table body
        const tbody = document.createElement('tbody');
        originalData.forEach(item => {
            const row = document.createElement('tr');
            visibleHeaders.forEach(header => {
                const td = document.createElement('td');
                let value = item[header];
                
                // Handle special cases like accessories
                if (header === 'accessories' && Array.isArray(value)) {
                    value = value.map(acc => acc.type || acc.inst_type || '').join(', ');
                }
                
                td.textContent = value || '';
                td.style.padding = '8px';
                td.style.border = '1px solid #ddd';
                row.appendChild(td);
            });
            tbody.appendChild(row);
        });
        table.appendChild(tbody);

        // Initialize new DataTable
        dataTable = $(table).DataTable({
            searching: false,
            paging: false,
            info: false,
            scrollX: true,
            order: [],
            columnDefs: [{
                targets: '_all',
                orderable: true
            }]
        });
    }

    // Create checkboxes and add to list
    headers.forEach(header => {
        const item = document.createElement('li');
        item.style.cssText = `
            padding: 8px 0;
            border-bottom: 1px solid #ddd;
            font-size: 16px;
            display: flex;
            align-items: center;
        `;

        // Create checkbox
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = true;
        checkbox.dataset.header = header;
        checkbox.style.marginRight = '10px';
        checkbox.style.cursor = 'pointer';

        // Add change event to update table
        checkbox.addEventListener('change', () => {
            updateTable();
        });

        // Create label
        const label = document.createElement('label');
        label.textContent = header;
        label.style.cursor = 'pointer';
        label.style.flexGrow = '1';

        // Add click handler to label
        label.addEventListener('click', (e) => {
            e.preventDefault(); // Prevent default label behavior
            checkbox.checked = !checkbox.checked;
            updateTable();
        });

        item.appendChild(checkbox);
        item.appendChild(label);
        list.appendChild(item);
    });

    // Add collapse functionality
    let isCollapsed = true; // Start collapsed
    headerDiv.addEventListener('click', () => {
        isCollapsed = !isCollapsed;
        if (isCollapsed) {
            list.style.maxHeight = '0';
            list.style.overflow = 'hidden';
            collapseIcon.style.transform = 'rotate(-90deg)';
        } else {
            list.style.maxHeight = '500px';
            list.style.overflow = 'auto';
            collapseIcon.style.transform = 'rotate(0deg)';
        }
    });

    // Assemble everything
    container.appendChild(headerDiv);
    container.appendChild(list);
    tableContainer.appendChild(table);
    container.appendChild(tableContainer);
    document.body.appendChild(container);

    // Initialize table with all columns
    updateTable();
}

</script>

</body>
</html>
