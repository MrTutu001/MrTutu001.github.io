<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!--Page Info-->
    <title>Light Rewrite</title>
    <link rel="icon" href="lightRewriteIconBlack.ico" type="image/x-icon">
    <!-- Imports -->
    <link rel="stylesheet" href="https://cdn.datatables.net/1.11.5/css/jquery.dataTables.min.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.datatables.net/1.11.5/js/jquery.dataTables.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 20px; 
        }
        h1 {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .icon {
            width: 30px; /* Adjust size of the icon */
            height: 30px;
            margin: 0 10px; /* Space between text and image */
        }
        .mirrored {
            transform: scaleX(-1); /* Mirroring the right image */
        }
        .menu-bar { 
            background-color: #f0f0f0; 
            padding: 10px; 
            display: flex; /* Use flex to align items */
            justify-content: flex-start; /* Align items to the left */
            width: 100%; /* Make menu bar full width */
            box-shadow: 0px 2px 5px rgba(0,0,0,0.2); /* Add slight shadow for depth */
            margin-bottom: 10px; /* Space below the menu */
        }
        .dropdown {
            position: relative; /* Position relative to the menu items */
            margin-right: 15px; /* Space between dropdowns */
        }
        .dropdown-content {
            display: none; 
            position: absolute; 
            background-color: white; 
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1;
            white-space: nowrap; /* Prevent wrapping */
        }
        .dropdown:hover .dropdown-content {
            display: block;
        }
        .file-upload, .search-option { margin: 0; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 8px 12px; border: 1px solid #ddd; }
        .dropdown-content a { padding: 8px 12px; display: block; text-decoration: none; }
        .dropdown-content a:hover { background-color: #f1f1f1; }
        .instruction { 
            text-align: center; 
            margin-bottom: 20px; 
            font-style: italic; 
            color: #555; 
            display: block; 
        }
        #searchInfo { 
            text-align: center; 
            margin-bottom: 10px; 
            font-weight: bold; 
            color: #007BFF; 
        }
    </style>
</head>
<body>

    <h1> <!--Title-->
        <img src="lightRewriteIconBlack.ico" alt="Left Icon" class="icon">
        Light Rewrite Web
        <img src="lightRewriteIconBlack.ico" alt="Right Icon" class="icon mirrored">
    </h1>

<div class="menu-bar"> <!--Menu Bar-->
    <div class="dropdown">
        <button>File</button>
        <div class="dropdown-content">
            <div class="file-upload">
                <a href="#" class="upload-trigger">Upload -></a>
                <div class="upload-submenu" style="position: absolute; left: 100%; top: 0; display: none; background-color: white; border: 1px solid #ddd; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);">
                    <label for="fileInput" class="file-upload">
                        <input type="file" id="fileInput" accept=".xml" style="display: none;" onchange="processFile()">
                        <a href="#" onclick="document.getElementById('fileInput').click(); return false;">XML</a>
                    </label>
                    <label for="csvFileInput" class="file-upload">
                        <input type="file" id="csvFileInput" accept=".csv" style="display: none;" onchange="processCSVFile()">
                        <a href="#" onclick="document.getElementById('csvFileInput').click(); return false;">CSV</a>
                    </label>
                    <label for="xlsxFileInput" class="file-upload">
                        <input type="file" id="xlsxFileInput" accept=".xlsx" style="display: none;" onchange="processXLSXFile()">
                        <a href="#" onclick="document.getElementById('xlsxFileInput').click(); return false;">Excel</a>
                    </label>
                </div>
                <script>
                    document.querySelector('.upload-trigger').addEventListener('mouseover', function(e) {
                        document.querySelector('.upload-submenu').style.display = 'block';
                    });
                    document.querySelector('.file-upload').addEventListener('mouseleave', function(e) {
                        document.querySelector('.upload-submenu').style.display = 'none';
                    });
                </script>
            </div>
            <div class="showInfo">
                <a href="#" onclick="getShowInfo()">Show Info</a>
            </div>
            <div class="clearData">
                <a href="#" onclick="clearStoredData()">Reset</a>
            </div>
        </div>
    </div>

    <div class="dropdown">
        <button>Tools</button>
        <div class="dropdown-content">
            <div class="tools">
                <a href="#" onclick="populateAddressFromDimmer()">Dimmer to Address</a>
            </div>
            <div class="tools">
                <a href="#" onclick="compareCSVWithOriginal()">Compare</a>
            </div>
        </div>
    </div>

    <div class="dropdown">
        <button>Views</button>
        <div class="dropdown-content">
            <div class="views">
                <a href="#" onclick="showMainView()">Main</a>
            </div>
            <div class="views">
                <a href="#" onclick="createSpreadsheet()">Work Notes</a>
            </div>
        </div>
    </div>
    
    <div class="dropdown">
        <button>Search</button>
        <div class="dropdown-content">
            <div class="search-option">
                <a href="#" onclick="searchByChannel()">Channel</a>
            </div>
            <div class="search-option">
                <a href="#" onclick="searchByAddress()">Address</a>
            </div>
            <div class="search-option">
                <a href="#" onclick="searchByPosition()">Position</a>
            </div>
            <div class="search-option">
                <a href="#" onclick="resetSearch()">Reset</a> <!-- Reset option added -->
            </div>
        </div>
    </div>

    <div class="dropdown">
        <button>Exports</button>
        <div class="dropdown-content">
            <div class="exports">
                <a href="#" class="export-trigger">Paperwork -></a>
                <div class="exports-submenu" style="position: absolute; left: 100%; top: 0; display: none; background-color: white; border: 1px solid #ddd; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);">
                    <div class="exports">
                        <a href="#" onclick="exportChannelHookup()">Channel Hookup</a>
                    </div>
                    <div class="exports">
                        <a href="#" onclick="exportInstrumentSchedule()">Instrument Schedule</a>
                    </div>
                    <div class="exports">
                        <a href="#" onclick="exportColorCount()">Color Count</a>
                    </div>
                    <div class="exports">
                        <a href="#" onclick="exportInstrumentTypeCount()">Instrument Count</a>
                    </div>
                    <div class="exports">
                        <a href="#" onclick="exportWorkNotes()">Work Notes</a>
                    </div>
                </div>
                <script>
                    document.querySelector('.export-trigger').addEventListener('mouseover', function(e) {
                        document.querySelector('.exports-submenu').style.display = 'block';
                    });
                    document.querySelector('.exports').addEventListener('mouseleave', function(e) {
                        document.querySelector('.exports-submenu').style.display = 'none';
                    });
                </script>
            </div>
            <div class="exports">
                <a href="#" onclick="generatePatchFile()">EOS Patch</a>
            </div>
            <div class="exports">
                <a href="#" onclick="exportTableToCSV()">CSV</a>
            </div>
        </div>
    </div>
    
</div>

<div class="instruction" id="instructionBox2">"Perform a complete export on exit" in Vecorworks</div> <!-- Instruction box positioned below the menu -->
<div class="instruction" id="instructionBox">Use the File menu to upload an XML file.</div> <!-- Instruction box positioned below the menu -->
<div class="instruction" id="instructionBox3">Instructions on how to get XML file:</div> <!-- Instruction box positioned below the menu -->
<div class="instruction" id="instructionBox4">In Vectoworks go: Spotlight > Spotlight Settings > Spotlight Preferences > Lightwright > Use Automatic Lightwright Data Exchange > Perform a complete export on exit > OK</div> <!-- Instruction box positioned below the menu -->


<div id="searchInfo" style="display: none;">Currently Searching: <span id="searchCriteria"></span></div> <!-- Search info box -->

<table id="dataTable" class="display" style="display: none;">
    <thead>
        <tr> <!--Data Point Add-->
            <th>Channel</th>
            <th>Position</th>
            <th>Unit</th>
            <th>Purpose</th>
            <th>Type</th>
            <th>Dimmer</th>
            <th>Address</th>
            <th>Color</th>
            <th>Gobo</th>
            <th>Accessories</th>
        </tr>
    </thead>
    <tbody id="tableBody">
    </tbody>
</table>

<script>
//Version
const version = 'v1_6_3'
//Globals    
let originalData = []; // Global variable to store original data
let tableInitialized = false; // Keep track of whether the DataTable has been initialized
let instrumentData = []; //Globalize instrumeData?
let uploadedFileName = ''; // Global variable to store the uploaded file name
// Global variables for show information
let showName = '';
let designer = '';
let headElectrician = '';
// Add this at the top of your script section, with other global variables
let workNotesContainer = null; // Global reference to work notes container
const workNoteHeaders = ['Channel', 'Position', 'Unit', 'Purpose', 'Type', 'Dimmer', 'Address', 'Color', 'Gobo', 'Accessories', 'Notes'];

// Add these functions to handle saving/loading state
function saveState() {
    const state = {
        originalData,
        uploadedFileName,
        showName,
        designer,
        headElectrician,
        workNotes: workNotesContainer ? workNotesContainer.innerHTML : null,
        version // Include version for compatibility checking
    };
    localStorage.setItem('lightRewriteState', JSON.stringify(state));
}

function loadState() {
    const savedState = localStorage.getItem('lightRewriteState');
    if (savedState) {
        const state = JSON.parse(savedState);
        
        // Version check
        if (state.version !== version) {
            localStorage.removeItem('lightRewriteState');
            return false;
        }

        originalData = state.originalData;
        uploadedFileName = state.uploadedFileName;
        showName = state.showName;
        designer = state.designer;
        headElectrician = state.headElectrician;

        // Restore the table if there's data
        if (originalData.length > 0) {
            document.getElementById('dataTable').style.display = 'block';
            document.getElementById('instructionBox').style.display = 'none';
            document.getElementById('instructionBox2').style.display = 'none';
            document.getElementById('instructionBox3').style.display = 'none';
            document.getElementById('instructionBox4').style.display = 'none';
            
            // Populate the table
            const tableBody = document.getElementById('tableBody');
            tableBody.innerHTML = '';
            originalData.forEach(item => {
                const accessoriesText = item.accessories && item.accessories.length > 0
                    ? item.accessories.map(acc => acc.type || "Unknown").join("; ")
                    : "";
                
                const row = `<tr>
                    <td>${item.channel}</td>
                    <td>${item.position}</td>
                    <td>${item.unit}</td>
                    <td>${item.purpose}</td>
                    <td>${item.type}</td>
                    <td>${item.dimmer}</td>
                    <td>${item.address}</td>
                    <td>${item.color}</td>
                    <td>${item.gobo}</td>
                    <td>${accessoriesText}</td>
                </tr>`;
                tableBody.innerHTML += row;
            });

            // Initialize or refresh DataTable
            if (!tableInitialized) {
                $('#dataTable').DataTable({
                    searching: false,
                    paging: false,
                    info: false,
                    order: [],
                    columnDefs: [{
                        targets: 1,
                        orderData: [1, 2],
                    }]
                });
                tableInitialized = true;
            } else {
                $('#dataTable').DataTable().clear().rows.add($(tableBody).children()).draw();
            }
        }

        // Restore work notes if they exist
        if (state.workNotes) {
            workNotesContainer = document.createElement('div');
            workNotesContainer.id = 'workNotesTable';
            workNotesContainer.style.overflowX = 'auto';
            workNotesContainer.innerHTML = state.workNotes;
            workNotesContainer.style.display = 'none';
            document.body.appendChild(workNotesContainer);
        }

        return true;
    }
    return false;
}

function processFile() {
    const fileInput = document.getElementById('fileInput');
    const file = fileInput.files[0];
    if (!file) {
        alert('Please select an XML file.');
        return;
    }

    // Store the uploaded file name (without the extension) for later use
    uploadedFileName = file.name.replace(/\.[^/.]+$/, ""); // Remove file extension

    const reader = new FileReader();
    reader.onload = function(event) {
        try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(event.target.result, "text/xml");

            const instrumentData = xmlDoc.querySelector("InstrumentData");
            const instruments = instrumentData ? Array.from(instrumentData.children) : [];

            if (instruments.length <= 0) {
                alert("No instrument entries found in the XML file.");
                return;
            }

            const tableBody = document.getElementById('tableBody');
            tableBody.innerHTML = ''; // Clear existing rows

            originalData = []; // Clear original data array

            // Start from the 6th instrument (index 5) to skip the first 5
            for (let i = 5; i < instruments.length; i++) { // Data Point Add
                const instrument = instruments[i];
                const channel = instrument.querySelector('Channel')?.textContent || '';
                const position = instrument.querySelector('Position')?.textContent || '';
                const unit = instrument.querySelector('Unit_Number')?.textContent || '';
                const purpose = instrument.querySelector('Purpose')?.textContent || '';
                const type = instrument.querySelector('Inst_Type')?.textContent || '';
                const dimmer = instrument.querySelector('Dimmer')?.textContent || '';
                const address = instrument.querySelector('Absolute_Address')?.textContent || '';
                const color = instrument.querySelector('Color')?.textContent || '';
                const gobo = instrument.querySelector('Template')?.textContent || '';

                // Parse accessories
                const accessories = [];
                const accessoriesElement = instrument.querySelector('Accessories');
                if (accessoriesElement) {
                    const accessoryItems = Array.from(accessoriesElement.children);
                    for (const accessory of accessoryItems) {
                        const accessoryType = accessory.querySelector('Inst_Type')?.textContent || 'Unknown';
                        //const accessorySymbol = accessory.querySelector('Symbol_Name')?.textContent || 'Unknown';
                        accessories.push({ type: accessoryType });
                    }
                }

                const accessoryText = accessories.map(a => `${a.type}`).join(', ');

                const row = `<tr> 
                    <td>${channel}</td>
                    <td>${position}</td>
                    <td>${unit}</td>
                    <td>${purpose}</td>
                    <td>${type}</td>
                    <td>${dimmer}</td>
                    <td>${address}</td>
                    <td>${color}</td>
                    <td>${gobo}</td>
                    <td>${accessoryText}</td>
                </tr>`; //Data Point Add
                tableBody.innerHTML += row;

                originalData.push({ channel, position, unit, purpose, type, dimmer, address, color, gobo, accessories }); //Data Point Add
            }

            document.getElementById('dataTable').style.display = 'block';
            document.getElementById('instructionBox').style.display = 'none';
            document.getElementById('instructionBox2').style.display = 'none';
            document.getElementById('instructionBox3').style.display = 'none';
            document.getElementById('instructionBox4').style.display = 'none';
            document.getElementById('searchInfo').style.display = 'none';

            if (!tableInitialized) {
                $('#dataTable').DataTable({
                    searching: false,
                    paging: false,
                    info: false,
                    order: [],
                    columnDefs: [
                        {
                            targets: 1,
                            orderData: [1, 2],
                        }
                    ]
                });
                tableInitialized = true;
            } else {
                $('#dataTable').DataTable().clear().rows.add($(tableBody).children()).draw();
            }

            saveState();

        } catch (error) {
            console.error("Error parsing XML file:", error);
            alert("An error occurred while processing the XML file. Please check the console for details.");
        }
    };

    reader.readAsText(file);
}


// Function to ask for show information and save it in global variables
function getShowInfo() {
    showName = prompt("Enter the name of the show:", showName || "Unnamed Show");
    designer = prompt("Enter the name of the designer:", designer || "Unknown Designer");
    headElectrician = prompt("Enter the name of the head electrician:", headElectrician || "Unknown Head Electrician");

    // Ensure variables are not empty if user clears them
    showName = showName ? showName : "Unnamed Show";
    designer = designer ? designer : "Unknown Designer";
    headElectrician = headElectrician ? headElectrician : "Unknown Head Electrician";

    saveState();
}


function searchByChannel() {
    const input = prompt("Enter a range (e.g., 1-5) or a list of channel numbers (e.g., 1,2,3):");
    if (input) {
        const filterValues = input.split(',').map(x => x.trim());
        const filteredData = originalData.filter(item => 
            filterValues.some(value => isInChannelRange(item.channel, value) || item.channel === value.trim())
        );

        const tableBody = document.getElementById('tableBody');
        tableBody.innerHTML = ''; // Clear existing rows


        filteredData.forEach(item => { //Data Point Add
            // Extract accessory types into a string, or show "N/A" if there are no accessories
            const accessoriesText = item.accessories && item.accessories.length > 0
                ? item.accessories.map(acc => acc.type || "Unknown").join("; ")
                : "N/A";
                
            const row = `<tr>
                <td>${item.channel}</td>
                <td>${item.position}</td>
                <td>${item.unit}</td>
                <td>${item.purpose}</td>
                <td>${item.type}</td>
                <td>${item.dimmer}</td>
                <td>${item.address}</td>
                <td>${item.color}</td>
                <td>${item.gobo}</td>
                <td>${accessoriesText}</td>
            </tr>`;
            tableBody.innerHTML += row;
        });

        $('#dataTable').DataTable().clear().rows.add($(tableBody).children()).draw();
        
        // Display the search criteria
        document.getElementById('searchInfo').style.display = 'block';
        document.getElementById('searchCriteria').innerText = input; // Show current search criteria
    }
}

function isInChannelRange(channel, input) {
    const rangePattern = /(\d+)-(\d+)/; // Regex to match ranges like 1-5
    const match = input.match(rangePattern);
    if (match) {
        const start = parseInt(match[1]);
        const end = parseInt(match[2]);
        return parseInt(channel) >= start && parseInt(channel) <= end;
    }
    return false;
}

function searchByAddress() {
    const input = prompt("Enter a range (e.g., 100-200) or a list of addresses (e.g., 100,150,200):");
    if (input) {
        const filterValues = input.split(',').map(x => x.trim());
        const filteredData = originalData.filter(item => 
            filterValues.some(value => isInAddressRange(item.address, value) || item.address === value.trim())
        );

        const tableBody = document.getElementById('tableBody');
        tableBody.innerHTML = ''; // Clear existing rows


        filteredData.forEach(item => { //Data Point Add
            // Extract accessory types into a string, or show "N/A" if there are no accessories
            const accessoriesText = item.accessories && item.accessories.length > 0
                ? item.accessories.map(acc => acc.type || "Unknown").join("; ")
                : "N/A";

            const row = `<tr>
                <td>${item.channel}</td>
                <td>${item.position}</td>
                <td>${item.unit}</td>
                <td>${item.purpose}</td>
                <td>${item.type}</td>
                <td>${item.dimmer}</td>
                <td>${item.address}</td>
                <td>${item.color}</td>
                <td>${item.gobo}</td>
                <td>${accessoriesText}</td>
            </tr>`;
            tableBody.innerHTML += row;
        });

        $('#dataTable').DataTable().clear().rows.add($(tableBody).children()).draw();
        
        // Display the search criteria
        document.getElementById('searchInfo').style.display = 'block';
        document.getElementById('searchCriteria').innerText = input; // Show current search criteria
    }
}

function isInAddressRange(address, input) {
    const rangePattern = /(\d+)-(\d+)/; // Regex to match ranges like 100-200
    const match = input.match(rangePattern);
    if (match) {
        const start = parseInt(match[1]);
        const end = parseInt(match[2]);
        return parseInt(address) >= start && parseInt(address) <= end;
    }
    return false;
}

async function searchByPosition() {
    const uniquePositions = [...new Set(originalData.map(item => item.position))]; // Get unique positions

    // Create the checkboxes dynamically
    let checkboxHTML = uniquePositions.map(position => {
        return `<label><input type="checkbox" value="${position}"> ${position}</label><br>`;
    }).join('');

    // Display the user selection box at the top
    const userSelectionBox = createSelectionBox(checkboxHTML);
    document.body.insertBefore(userSelectionBox, document.getElementById('dataTable').parentNode); // Insert above the table

    // Wait for the user to make their selection
    const userSelection = await promptUserToSelectPositions(userSelectionBox, checkboxHTML);

    if (userSelection) {
        const selectedPositions = userSelection.split(',').map(position => position.trim());
        const filteredData = originalData.filter(item => 
            selectedPositions.includes(item.position)
        );

        const tableBody = document.getElementById('tableBody');
        tableBody.innerHTML = ''; // Clear existing rows

        filteredData.forEach(item => { // Data Point Add
            // Extract accessory types into a string, or show "N/A" if there are no accessories
            const accessoriesText = item.accessories && item.accessories.length > 0
                ? item.accessories.map(acc => acc.type || "Unknown").join("; ")
                : "N/A";

            const row = `<tr>
                <td>${item.channel}</td>
                <td>${item.position}</td>
                <td>${item.unit}</td>
                <td>${item.purpose}</td>
                <td>${item.type}</td>
                <td>${item.dimmer}</td>
                <td>${item.address}</td>
                <td>${item.color}</td>
                <td>${item.gobo}</td>
                <td>${accessoriesText}</td>
            </tr>`;
            tableBody.innerHTML += row;
        });

        $('#dataTable').DataTable().clear().rows.add($(tableBody).children()).draw();
        
        // Display the search criteria
        document.getElementById('searchInfo').style.display = 'block';
        document.getElementById('searchCriteria').innerText = `Positions: ${userSelection}`; // Show current search criteria
    }
}

function createSelectionBox(checkboxHTML) {
    const box = document.createElement('div');
    box.id = 'selectionBox';
    box.innerHTML = `
        <h3>Select Positions</h3>
        <div>${checkboxHTML}</div>
        <button id="submitSelection">Submit</button>
    `;
    return box;
}

function promptUserToSelectPositions(userSelectionBox, checkboxHTML) {
    return new Promise((resolve) => {
        document.getElementById('submitSelection').addEventListener('click', () => {
            const selectedPositions = [...userSelectionBox.querySelectorAll('input[type="checkbox"]:checked')].map(input => input.value);
            resolve(selectedPositions.join(','));

            // Remove the selection box after submission
            document.body.removeChild(userSelectionBox);
        });
    });
}




function resetSearch() {
    const tableBody = document.getElementById('tableBody');
    tableBody.innerHTML = ''; // Clear existing rows

    // Re-add all original data entries
    originalData.forEach(item => {
        // Extract accessory types into a string, or show "N/A" if there are no accessories
        const accessoriesText = item.accessories && item.accessories.length > 0
            ? item.accessories.map(acc => acc.type || "Unknown").join("; ")
            : "";

        const row = `<tr>
            <td>${item.channel}</td>
            <td>${item.position}</td>
            <td>${item.unit}</td>
            <td>${item.purpose}</td>
            <td>${item.type}</td>
            <td>${item.dimmer}</td>
            <td>${item.address}</td>
            <td>${item.color}</td>
            <td>${item.gobo}</td>
            <td>${accessoriesText}</td>
        </tr>`; //Data Point Add
        tableBody.innerHTML += row;
    });

    // Redraw the DataTable
    $('#dataTable').DataTable().clear().rows.add($(tableBody).children()).draw();

    // Hide search info
    document.getElementById('searchInfo').style.display = 'none';
}


function exportChannelHookup() {
    function createHeader(pageNumber) { //Data Point Add
        return `
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                <h1 style="margin: 0;">Channel Hookup ${showName}</h1>
                <div style="text-align: center; font-size: 10px;">Designer: ${designer} | HE: ${headElectrician}</div>
                <div style="text-align: right; font-size: 10px;">Page ${pageNumber}...</div>
            </div>
            <div style="font-weight: bold; display: flex; justify-content: space-between; width: 100%;">
                <span style="width: 12%;">Channel</span>
                <span style="width: 12%;">Position</span>
                <span style="width: 12%;">Unit</span>
                <span style="width: 12%;">Purpose</span>
                <span style="width: 12%;">Type</span>
                <span style="width: 12%;">Address</span>
                <span style="width: 12%;">Color</span>
                <span style="width: 12%;">Gobo</span>
                <span style="width: 12%;">Accessories</span>
            </div>
            <hr style="margin: 5px 0; border: none; border-top: 1px solid #000;"/>
        `;
    }

    function createFooter(pageNumber) {
        return `
            <div style="text-align: center; font-size: 8px; margin-top: 20px;">
                <p>This was generated using Light Rewrite Web ${version}</p>
            </div>
        `;
    }

    const data = originalData.sort((a, b) => parseInt(a.channel) - parseInt(b.channel));

    if (data.length === 0) {
        alert('No instrument data available for export.');
        return;
    }

    const pdfDiv = document.createElement('div');
    pdfDiv.style.width = '100%';
    pdfDiv.style.fontSize = '12px';

    const instrumentsPerPage = 20;
    let pageNumber = 1;

    for (let i = 0; i < data.length; i += instrumentsPerPage) {
        const chunk = data.slice(i, i + instrumentsPerPage);
        const headerContent = createHeader(pageNumber);

        let pdfContent = '';
        chunk.forEach((instrument) => {
            // Extract accessories if they exist and only display the type
            const accessoriesText = instrument.accessories && instrument.accessories.length > 0
                ? instrument.accessories.map(acc => acc.type || "Unknown").join("; ")
                : "N/A";

            pdfContent += `<div style="display: flex; justify-content: space-between; margin-bottom: 10px; width: 100%;">
                <span style="width: 12%;">${instrument.channel}</span>
                <span style="width: 12%;">${instrument.position}</span>
                <span style="width: 12%;">${instrument.unit}</span>
                <span style="width: 12%;">${instrument.purpose}</span>
                <span style="width: 12%;">${instrument.type}</span>
                <span style="width: 12%;">${instrument.address}</span>
                <span style="width: 12%;">${instrument.color}</span>
                <span style="width: 12%;">${instrument.gobo}</span>
                <span style="width: 12%;">${accessoriesText}</span>
            </div>
            <hr style="margin: 5px 0; border: none; border-top: 1px solid #000;"/>`;
        });//Data Point Add

        const footerContent = createFooter(pageNumber);
        pdfDiv.innerHTML += headerContent + pdfContent + footerContent;

        if (i + instrumentsPerPage < data.length) {
            pdfDiv.innerHTML += '<div style="page-break-after: always;"></div>';
        }

        pageNumber++;
    }

    const pdfOptions = {
        margin:       0.5,
        filename:     `${uploadedFileName}_channel_hookup.pdf`,
        image:        { type: 'jpeg', quality: 0.98 },
        html2canvas:  { scale: 2 },
        jsPDF:        { unit: 'in', format: 'letter', orientation: 'landscape' }
    };

    html2pdf().from(pdfDiv).set(pdfOptions).save();
}

function exportInstrumentSchedule() {
    function createHeader(position, pageNumber) { //Data Point Add
        return `
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                <h1 style="margin: 0;">Instrument Schedule</h1>
                <div style="text-align: center; font-size: 10px;">Designer: ${designer} | HE: ${headElectrician}</div>
                <div style="text-align: right; font-size: 10px;">Page ${pageNumber}...</div>
            </div>
            <div style="text-align: left; font-size: 15px; font-weight: bold">Position: ${position}</div>
            <div style="font-weight: bold; display: flex; justify-content: space-between; width: 100%; margin-top: 10px;">
                <span style="width: 12%;">Unit</span>
                <span style="width: 12%;">Purpose</span>
                <span style="width: 12%;">Type</span>
                <span style="width: 12%;">Channel</span>
                <span style="width: 12%;">Address</span>
                <span style="width: 12%;">Color</span>
                <span style="width: 12%;">Gobo</span>
                <span style="width: 12%;">Accessories</span>
            </div>
            <hr style="margin: 5px 0; border: none; border-top: 1px solid #000;"/>
        `;
    }

    function createFooter(pageNumber) {
        return `
            <div style="text-align: center; font-size: 8px; margin-top: 20px;">
                <p>This was generated using Light Rewrite Web ${version}</p>
            </div>
        `;
    }

    const data = originalData.sort((a, b) => {
        if (a.position === b.position) {
            return parseInt(a.unit) - parseInt(b.unit);
        }
        return a.position.localeCompare(b.position);
    });

    if (data.length === 0) {
        alert('No instrument data available for export.');
        return;
    }

    const pdfDiv = document.createElement('div');
    pdfDiv.style.width = '100%';
    pdfDiv.style.fontSize = '12px';

    const instrumentsPerPage = 14; // Limit to 15 instruments per page
    let pageNumber = 1;
    let lastPosition = ''; // Track the last position to detect changes
    let instrumentsInPosition = 0; // Track the number of instruments on the current page

    for (let i = 0; i < data.length; i++) {
        const instrument = data[i];

        // If the position is different, or we have reached the instrument limit per page, 
        // add a page break and reset the instrument count
        if (instrument.position !== lastPosition || instrumentsInPosition === instrumentsPerPage) {
            // If it's not the first position, add a page break
            if (lastPosition !== '') {
                pdfDiv.innerHTML += '<div style="page-break-after: always;"></div>';
            }

            // Add the header for the new position
            pdfDiv.innerHTML += createHeader(instrument.position, pageNumber);
            lastPosition = instrument.position; // Update last position
            instrumentsInPosition = 0; // Reset counter for instruments

            pageNumber++; // Increment page number
        }

        // Add the instrument to the page
        const accessoriesText = instrument.accessories && instrument.accessories.length > 0
            ? instrument.accessories.map(acc => acc.type || "Unknown").join("; ")
            : "N/A";

        pdfDiv.innerHTML += `<div style="display: flex; justify-content: space-between; margin-bottom: 10px; width: 100%;">
            <span style="width: 12%;">${instrument.unit}</span>
            <span style="width: 12%;">${instrument.purpose}</span>
            <span style="width: 12%;">${instrument.type}</span>
            <span style="width: 12%;">${instrument.channel}</span>
            <span style="width: 12%;">${instrument.address}</span>
            <span style="width: 12%;">${instrument.color}</span>
            <span style="width: 12%;">${instrument.gobo}</span>
            <span style="width: 12%;">${accessoriesText}</span>
        </div>
        <hr style="margin: 5px 0; border: none; border-top: 1px solid #000;"/>`; //Data Point Add

        // Increment instrument count for the current page
        instrumentsInPosition++;
         // If we have reached the limit for the page, insert a page break and footer
         if (instrumentsInPosition === instrumentsPerPage) {
            // Add the footer at the bottom of the page after the instruments
            pdfDiv.innerHTML += createFooter(pageNumber);
        }

        // If it's the last instrument for this position or last in data, insert the page break
        if (i === data.length - 1 || data[i + 1].position !== instrument.position) {
            const footerContent = createFooter(pageNumber);
            pdfDiv.innerHTML += footerContent;
        }
    }

    const pdfOptions = {
        margin:       0.5,
        filename:     `${uploadedFileName}_instrument_schedule.pdf`,
        image:        { type: 'jpeg', quality: 0.98 },
        html2canvas:  { scale: 2 },
        jsPDF:        { unit: 'in', format: 'letter', orientation: 'landscape' }
    };

    html2pdf().from(pdfDiv).set(pdfOptions).save();
}

function exportColorCount() {
    function createHeader(pageNumber) { //Data Point Add
        return `
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                <h1 style="margin: 0;">Color Count ${showName}</h1>
                <div style="text-align: center; font-size: 10px;">Designer: ${designer} | HE: ${headElectrician}</div>
                <div style="text-align: right; font-size: 10px;">Page ${pageNumber}...</div>
            </div>
            <div style="font-weight: bold; display: flex; justify-content: space-between; width: 100%;">
                <span style="width: 45%;">Color</span>
                <span style="width: 45%;">Instrument Type</span>
                <span style="width: 10%;">Count</span>
            </div>
            <hr style="margin: 5px 0; border: none; border-top: 1px solid #000;"/>
        `;
    }

    function createFooter(pageNumber) {
        return `
            <div style="text-align: center; font-size: 8px; margin-top: 20px;">
                <p>This was generated using Light Rewrite Web ${version}</p>
            </div>
        `;
    }

    // Create a map to count colors by instrument type (using "type" field)
    const colorCount = {};

    originalData.forEach(instrument => {
        const color = instrument.color || "Unknown";  // Default to "Unknown" if no color
        const instType = instrument.type || "Unknown";  // Use "type" for instrument type

        // Debugging: Log the inst_type and color for each instrument
        console.log(`Instrument: ${instrument.channel}, Color: ${color}, Instrument Type: ${instType}`);

        if (!colorCount[color]) {
            colorCount[color] = {};
        }

        if (!colorCount[color][instType]) {
            colorCount[color][instType] = 0;
        }

        colorCount[color][instType]++;
    });

    // Flatten the colorCount object into an array for easy PDF generation
    const colorReport = [];
    for (const color in colorCount) {
        for (const instType in colorCount[color]) {
            colorReport.push({
                color: color,
                instType: instType,
                count: colorCount[color][instType]
            });
        }
    }

    // Sort the report alphabetically by color and instrument type
    colorReport.sort((a, b) => {
        if (a.color === b.color) {
            return a.instType.localeCompare(b.instType);
        }
        return a.color.localeCompare(b.color);
    });

    if (colorReport.length === 0) {
        alert('No color data available for export.');
        return;
    }

    const pdfDiv = document.createElement('div');
    pdfDiv.style.width = '100%';
    pdfDiv.style.fontSize = '12px';

    const itemsPerPage = 20;
    let pageNumber = 1;

    for (let i = 0; i < colorReport.length; i += itemsPerPage) {
        const chunk = colorReport.slice(i, i + itemsPerPage);
        const headerContent = createHeader(pageNumber);

        let pdfContent = '';
        chunk.forEach((report) => {
            pdfContent += `<div style="display: flex; justify-content: space-between; margin-bottom: 10px; width: 100%;">
                <span style="width: 45%;">${report.color}</span>
                <span style="width: 45%;">${report.instType}</span>
                <span style="width: 10%;">${report.count}</span>
            </div>
            <hr style="margin: 5px 0; border: none; border-top: 1px solid #000;"/>`;
        });

        const footerContent = createFooter(pageNumber);
        pdfDiv.innerHTML += headerContent + pdfContent + footerContent;

        if (i + itemsPerPage < colorReport.length) {
            pdfDiv.innerHTML += '<div style="page-break-after: always;"></div>';
        }

        pageNumber++;
    }

    const pdfOptions = {
        margin:       0.5,
        filename:     `${uploadedFileName}_color_count.pdf`,
        image:        { type: 'jpeg', quality: 0.98 },
        html2canvas:  { scale: 2 },
        jsPDF:        { unit: 'in', format: 'letter', orientation: 'landscape' }
    };

    html2pdf().from(pdfDiv).set(pdfOptions).save();
}

function exportInstrumentTypeCount() {
    function createHeader(pageNumber) {
        return `
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                <h1 style="margin: 0;">Instrument Type Count ${showName}</h1>
                <div style="text-align: center; font-size: 10px;">Designer: ${designer} | HE: ${headElectrician}</div>
                <div style="text-align: right; font-size: 10px;">Page ${pageNumber}...</div>
            </div>
            <div style="font-weight: bold; display: flex; justify-content: space-between; width: 100%;">
                <span style="width: 80%;">Instrument Type</span>
                <span style="width: 20%;">Count</span>
            </div>
            <hr style="margin: 5px 0; border: none; border-top: 1px solid #000;"/>
        `;
    }

    function createFooter(pageNumber) {
        return `
            <div style="text-align: center; font-size: 8px; margin-top: 20px;">
                <p>This was generated using Light Rewrite Web ${version}</p>
            </div>
        `;
    }

    // Create a map to count the instrument types
    const typeCount = {};

    originalData.forEach(instrument => {
        const instType = instrument.type || "Unknown";  // Use "type" field for instrument type

        // Debugging: Log the instrument type for each instrument
        console.log(`Instrument: ${instrument.channel}, Instrument Type: ${instType}`);

        if (!typeCount[instType]) {
            typeCount[instType] = 0;
        }

        typeCount[instType]++;
    });

    // Convert the typeCount object into an array for easy PDF generation
    const typeReport = [];
    for (const instType in typeCount) {
        typeReport.push({
            instType: instType,
            count: typeCount[instType]
        });
    }

    // Sort the report alphabetically by instrument type
    typeReport.sort((a, b) => a.instType.localeCompare(b.instType));

    if (typeReport.length === 0) {
        alert('No instrument type data available for export.');
        return;
    }

    const pdfDiv = document.createElement('div');
    pdfDiv.style.width = '100%';
    pdfDiv.style.fontSize = '12px';

    const itemsPerPage = 20;
    let pageNumber = 1;

    for (let i = 0; i < typeReport.length; i += itemsPerPage) {
        const chunk = typeReport.slice(i, i + itemsPerPage);
        const headerContent = createHeader(pageNumber);

        let pdfContent = '';
        chunk.forEach((report) => {
            pdfContent += `<div style="display: flex; justify-content: space-between; margin-bottom: 10px; width: 100%;">
                <span style="width: 80%;">${report.instType}</span>
                <span style="width: 20%;">${report.count}</span>
            </div>
            <hr style="margin: 5px 0; border: none; border-top: 1px solid #000;"/>`;
        });

        const footerContent = createFooter(pageNumber);
        pdfDiv.innerHTML += headerContent + pdfContent + footerContent;

        if (i + itemsPerPage < typeReport.length) {
            pdfDiv.innerHTML += '<div style="page-break-after: always;"></div>';
        }

        pageNumber++;
    }

    const pdfOptions = {
        margin:       0.5,
        filename:     `${uploadedFileName}_instrument_type_count.pdf`,
        image:        { type: 'jpeg', quality: 0.98 },
        html2canvas:  { scale: 2 },
        jsPDF:        { unit: 'in', format: 'letter', orientation: 'landscape' }
    };

    html2pdf().from(pdfDiv).set(pdfOptions).save();
}

function generatePatchFile() {
    if (!originalData || originalData.length === 0) {
        alert("No data available to generate the patch file.");
        return;
    }

    // Define the headers for the ETC EOS Patch file
    let patchFileContent = "Purpose\tChannel\tAddress\tInstrument Type\tDevice Type\n";

    // Populate each row based on the parsed instrument data
    for (const instrument of originalData) {
        const purpose = instrument.purpose || "N/A";
        const channel = instrument.channel || "N/A";
        const address = instrument.address || "N/A";
        const instType = instrument.type || "N/A";
        const deviceType = "Light"; // Static value as per example output

        // Append each row to the content
        patchFileContent += `${purpose}\t${channel}\t${address}\t${instType}\t${deviceType}\n`;
    }

    // Create a blob and download the file
    const blob = new Blob([patchFileContent], { type: "text/plain" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = `${uploadedFileName}_Patch.txt`;
    link.click();
}

function populateAddressFromDimmer() {
    if (!originalData || originalData.length === 0) {
        alert("No data available to populate addresses.");
        return;
    }

    // Prompt the user to input the starting universe for dimmer 1
    let startingUniverse = parseInt(prompt("Enter the starting universe for dimmer 1:", "1"), 10);
    if (isNaN(startingUniverse) || startingUniverse < 1) {
        alert("Invalid universe number. Please enter a valid number starting from 1.");
        return;
    }

    // Loop through each instrument and assign dimmer value to address if address is empty or 0
    for (const instrument of originalData) {
        if ((!instrument.address || instrument.address === "0") && instrument.dimmer) {
            const dimmerValue = parseInt(instrument.dimmer, 10);

            if (!isNaN(dimmerValue) && dimmerValue > 0) {
                // Calculate the correct address using the formula
                const address = dimmerValue + ((startingUniverse - 1) * 512);
                instrument.address = address.toString();
            }
        }
    }
    resetSearch()
}

function exportTableToCSV() {
    // Initialize CSV content with headers
    let csvContent = "Channel,Position,Unit,Purpose,Type,Dimmer,Address,Color,Gobo,Accessories\n";

    // Iterate through each instrument in originalData
    for (const instrument of originalData) {
        let row = [
            instrument.channel || '',
            instrument.position || '',
            instrument.unit || '',
            instrument.purpose || '',
            instrument.type || '',
            instrument.dimmer || '',
            instrument.address || '',
            instrument.color || '',
            instrument.gobo || ''
        ];

        // Handle accessories
        let accessories = '';
        if (Array.isArray(instrument.accessories)) {
            accessories = instrument.accessories.map(acc => {
                return Object.entries(acc)
                    .filter(([key]) => key === 'type') // Only keep the type field
                    .map(([key, value]) => value) // Just take the value
                    .join(';');
            }).join('|');
        }
        row.push(accessories);

        // Escape fields and join into a CSV row
        csvContent += row.map(field => `"${(field + '').replace(/"/g, '""')}"`).join(',') + '\n';
    }

    // Create a Blob from the CSV string
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    
    // Create a download link and trigger the download
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', `${uploadedFileName}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

///Work Notes
// Function to create the table and handle auto-fill functionality
function createSpreadsheet() {
    // Hide the original DataTable
    document.getElementById('dataTable').style.display = 'none';
    
    // If work notes container already exists, just show it
    if (workNotesContainer) {
        workNotesContainer.style.display = 'block';
        return;
    }

    // Create a container for the table
    workNotesContainer = document.createElement('div');
    workNotesContainer.id = 'workNotesTable';
    workNotesContainer.style.overflowX = 'auto';
    document.body.appendChild(workNotesContainer);

    // Create the table element
    const table = document.createElement('table');
    table.style.width = '100%';
    table.style.borderCollapse = 'collapse';
    
    // Keep track of sort state
    const sortState = {
        column: null,
        ascending: true
    };

    // Create the header row
    const headerRow = document.createElement('tr');
    workNoteHeaders.forEach(header => {
        const th = document.createElement('th');
        th.innerText = header;
        th.style.border = '1px solid black';
        th.style.padding = '8px';
        th.style.backgroundColor = '#f2f2f2';
        th.style.cursor = 'pointer';
        
        // Set specific widths for columns
        if (header === 'Channel') {
            th.style.width = '60px';  // Adjust this value as needed
        } else if (header === 'Notes') {
            th.style.width = '200px'; // Optional: make Notes column wider
        }
        
        // Add click event for sorting
        th.addEventListener('click', () => {
            sortTable(header, table);
        });
        
        headerRow.appendChild(th);
    });
    table.appendChild(headerRow);

    // Add a single row with an input field for the channel
    addInputRow(table);

    // Append table to container
    workNotesContainer.appendChild(table);

    function sortTable(header, table) {
        // Get all rows except header and input row
        const rows = Array.from(table.rows).slice(1, -1);
        const inputRow = table.rows[table.rows.length - 1];
        
        // Determine column index
        const columnIndex = workNoteHeaders.indexOf(header);
        
        // Update sort state
        if (sortState.column === header) {
            sortState.ascending = !sortState.ascending;
        } else {
            sortState.column = header;
            sortState.ascending = true;
        }

        // Sort rows
        rows.sort((a, b) => {
            let aValue = a.cells[columnIndex].textContent;
            let bValue = b.cells[columnIndex].textContent;

            // Handle numeric sorting for Channel, Unit, Dimmer, and Address
            if (['Channel', 'Unit', 'Dimmer', 'Address'].includes(header)) {
                aValue = parseInt(aValue) || 0;
                bValue = parseInt(bValue) || 0;
                return sortState.ascending ? aValue - bValue : bValue - aValue;
            }

            // String comparison for other columns
            return sortState.ascending ? 
                aValue.localeCompare(bValue) : 
                bValue.localeCompare(aValue);
        });

        // Remove existing rows except header and input
        while (table.rows.length > 2) {
            table.deleteRow(1);
        }

        // Add sorted rows back
        rows.forEach(row => {
            table.insertBefore(row, inputRow);
        });
    }

    function addInputRow(table) {
        const row = document.createElement('tr');
        const cell = document.createElement('td');
        cell.colSpan = workNoteHeaders.length;
        cell.style.padding = '10px';
        cell.style.display = 'flex';
        cell.style.gap = '10px';

        // Create select for input type
        const select = document.createElement('select');
        select.style.width = '100px';
        const options = ['Channel', 'Address', 'Dimmer', 'Color'];
        options.forEach(opt => {
            const option = document.createElement('option');
            option.value = opt.toLowerCase();
            option.text = opt;
            select.appendChild(option);
        });

        // Create input for entering the value
        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = 'Enter Value';
        input.style.flex = '1';

        // Create input for notes
        const notesInput = document.createElement('input');
        notesInput.type = 'text';
        notesInput.placeholder = 'Add Notes';
        notesInput.style.flex = '1';
        
        // Function to handle the enter key submission
        const handleSubmit = () => {
            const searchType = select.value;
            if (input.value.trim() !== '') {
                handleInput(input.value, searchType, notesInput.value);
                table.removeChild(row);
                addInputRow(table);
                table.lastElementChild.querySelector('input').focus();
            }
        };

        // Add keypress listeners for both input fields
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                if (notesInput.value.trim() === '') {
                    notesInput.focus();
                } else {
                    handleSubmit();
                }
            }
        });

        notesInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                handleSubmit();
            }
        });
        
        cell.appendChild(select);
        cell.appendChild(input);
        cell.appendChild(notesInput);
        row.appendChild(cell);
        table.appendChild(row);
        input.focus();
    }

    function handleInput(inputValue, searchType, notes) {
        let matchingData = [];

        switch(searchType) {
            case 'channel':
                matchingData = originalData.filter(item => item.channel === inputValue);
                break;
            case 'address':
                matchingData = originalData.filter(item => item.address === inputValue);
                break;
            case 'dimmer':
                matchingData = originalData.filter(item => item.dimmer === inputValue);
                break;
            case 'color':
                matchingData = originalData.filter(item => 
                    item.color && item.color.toLowerCase().includes(inputValue.toLowerCase())
                );
                break;
        }

        if (matchingData.length > 0) {
            matchingData.forEach(rowData => {
                const row = document.createElement('tr');
                
                // Add all data cells first
                workNoteHeaders.forEach(header => {
                    const cell = document.createElement('td');
                    cell.style.border = '1px solid black';
                    cell.style.padding = '8px';
                    
                    if (header === 'Delete') {
                        // Create delete button
                        const deleteButton = document.createElement('button');
                        deleteButton.innerHTML = '';
                        deleteButton.style.cursor = 'pointer';
                        deleteButton.style.border = 'none';
                        deleteButton.style.background = 'none';
                        deleteButton.style.color = 'red';
                        deleteButton.style.fontSize = '20px';
                        deleteButton.style.padding = '0';
                        deleteButton.title = 'Delete Row';
                        
                        deleteButton.onclick = function() {
                            row.remove();
                            saveState();
                        };
                        
                        cell.style.width = '30px';
                        cell.style.textAlign = 'center';
                        cell.appendChild(deleteButton);
                    } else if (header === 'Notes') {
                        cell.innerText = notes || '';
                    } else if (header === 'Accessories' && Array.isArray(rowData.accessories)) {
                        cell.innerText = rowData.accessories.map(acc => acc.type).join(', ') || '';
                    } else {
                        cell.innerText = rowData[header.toLowerCase()] || '';
                    }
                    
                    row.appendChild(cell);
                });
                
                // Add delete row button
                const deleteRowCell = document.createElement('td');
                const deleteRowButton = document.createElement('button');
                deleteRowButton.innerHTML = 'Delete Row';
                deleteRowButton.style.cursor = 'pointer';
                deleteRowButton.onclick = function() {
                    row.remove();
                    saveState();
                };
                deleteRowCell.appendChild(deleteRowButton);
                row.appendChild(deleteRowCell);
                
                table.insertBefore(row, table.lastElementChild);
            });
        } else {
            alert(`No fixture found with ${searchType} ${inputValue}`);
        }
    }

    // Add saveState() calls after table modifications
    const originalHandleInput = handleInput;
    handleInput = function(...args) {
        originalHandleInput.apply(this, args);
        saveState();
    };
}

function showMainView() {
    // Show the original table
    document.getElementById('dataTable').style.display = 'block';
    
    // Hide the work notes table if it exists (but don't remove it)
    if (workNotesContainer) {
        workNotesContainer.style.display = 'none';
    }
}

function exportWorkNotes() {
    if (!workNotesContainer || !workNotesContainer.querySelector('table')) {
        alert('No work notes available to export.');
        return;
    }

    // Create a clone of the work notes table
    const tableClone = workNotesContainer.querySelector('table').cloneNode(true);
    
    // Remove the last row (input row) from the clone
    tableClone.deleteRow(-1);

    // Create a container for the PDF content
    const pdfContent = document.createElement('div');
    pdfContent.style.padding = '20px';

    // Add header
    const header = document.createElement('div');
    header.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 20px;">
            <h1 style="margin: 0;">Work Notes - ${showName || 'Unnamed Show'}</h1>
            <div style="text-align: right; font-size: 12px;">
                <p>Designer: ${designer || 'Unknown'}</p>
                <p>Head Electrician: ${headElectrician || 'Unknown'}</p>
                <p>Date: ${new Date().toLocaleDateString()}</p>
            </div>
        </div>
    `;
    pdfContent.appendChild(header);

    // Style the table for PDF
    tableClone.style.width = '100%';
    tableClone.style.marginTop = '20px';
    tableClone.style.fontSize = '12px';
    
    // Remove the delete column
    const deleteColumnIndex = workNoteHeaders.indexOf('Delete');
    if (deleteColumnIndex !== -1) {
        Array.from(tableClone.rows).forEach(row => {
            row.deleteCell(deleteColumnIndex);
        });
    }

    pdfContent.appendChild(tableClone);

    // Add footer
    const footer = document.createElement('div');
    footer.innerHTML = `
        <div style="text-align: center; font-size: 8px; margin-top: 20px;">
            <p>Generated using Light Rewrite Web ${version}</p>
        </div>
    `;
    pdfContent.appendChild(footer);

    // Configure PDF options
    const pdfOptions = {
        margin: 0.5,
        filename: `${uploadedFileName}_work_notes.pdf`,
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: { scale: 2 },
        jsPDF: { unit: 'in', format: 'letter', orientation: 'landscape' }
    };

    // Generate and download the PDF
    html2pdf().from(pdfContent).set(pdfOptions).save();
}

function clearStoredData() {
    if (confirm('Are you sure you want to clear all stored data? This cannot be undone.')) {
        // Clear localStorage
        localStorage.removeItem('lightRewriteState');
        
        // Reset all global variables
        originalData = [];
        tableInitialized = false;
        instrumentData = [];
        uploadedFileName = '';
        showName = '';
        designer = '';
        headElectrician = '';
        
        // Clear work notes if they exist
        if (workNotesContainer) {
            workNotesContainer.remove();
            workNotesContainer = null;
        }

        // Reset table display
        document.getElementById('dataTable').style.display = 'none';
        document.getElementById('instructionBox').style.display = 'block';
        document.getElementById('instructionBox2').style.display = 'block';
        document.getElementById('instructionBox3').style.display = 'block';
        document.getElementById('instructionBox4').style.display = 'block';
        document.getElementById('searchInfo').style.display = 'none';
        
        // Clear the table body
        document.getElementById('tableBody').innerHTML = '';
        
        // Destroy and reset DataTable if it exists
        if ($.fn.DataTable.isDataTable('#dataTable')) {
            $('#dataTable').DataTable().destroy();
        }
        
        // Reload the page to ensure a clean state
        location.reload();
    }
}

function processCSVFile() {
    const fileInput = document.getElementById('csvFileInput');
    const file = fileInput.files[0];
    if (!file) {
        alert('Please select a CSV file.');
        return;
    }

    // Store the uploaded file name (without the extension) for later use
    uploadedFileName = file.name.replace(/\.[^/.]+$/, ""); // Remove file extension

    const reader = new FileReader();
    reader.onload = function(event) {
        try {
            // Split the CSV content into lines
            const lines = event.target.result.split('\n');
            
            // Get headers from first line and clean them
            const headers = lines[0].split(',').map(header => 
                header.trim().replace(/^["']|["']$/g, '').toLowerCase()
            );

            // Validate required headers
            const requiredHeaders = ['channel', 'position', 'unit', 'purpose', 'type', 'dimmer', 'address', 'color', 'gobo', 'accessories'];
            const missingHeaders = requiredHeaders.filter(h => !headers.includes(h));
            
            if (missingHeaders.length > 0) {
                alert(`Missing required headers: ${missingHeaders.join(', ')}`);
                return;
            }

            const tableBody = document.getElementById('tableBody');
            tableBody.innerHTML = ''; // Clear existing rows
            originalData = []; // Clear original data array

            // Process each line (skip header)
            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue; // Skip empty lines

                // Split the line into values and clean them
                const values = lines[i].split(',').map(value => 
                    value.trim().replace(/^["']|["']$/g, '')
                );

                // Create data object using headers as keys
                const rowData = {};
                headers.forEach((header, index) => {
                    rowData[header] = values[index] || '';
                });

                // Parse accessories (assuming they're semicolon-separated in the CSV)
                const accessories = rowData.accessories ? rowData.accessories.split(';').map(acc => ({
                    type: acc.trim()
                })) : [];

                const accessoryText = accessories.map(a => a.type).join(', ');

                // Create table row
                const row = `<tr> 
                    <td>${rowData.channel}</td>
                    <td>${rowData.position}</td>
                    <td>${rowData.unit}</td>
                    <td>${rowData.purpose}</td>
                    <td>${rowData.type}</td>
                    <td>${rowData.dimmer}</td>
                    <td>${rowData.address}</td>
                    <td>${rowData.color}</td>
                    <td>${rowData.gobo}</td>
                    <td>${accessoryText}</td>
                </tr>`;
                tableBody.innerHTML += row;

                // Add to originalData
                originalData.push({
                    channel: rowData.channel,
                    position: rowData.position,
                    unit: rowData.unit,
                    purpose: rowData.purpose,
                    type: rowData.type,
                    dimmer: rowData.dimmer,
                    address: rowData.address,
                    color: rowData.color,
                    gobo: rowData.gobo,
                    accessories
                });
            }

            // Update UI
            document.getElementById('dataTable').style.display = 'block';
            document.getElementById('instructionBox').style.display = 'none';
            document.getElementById('instructionBox2').style.display = 'none';
            document.getElementById('instructionBox3').style.display = 'none';
            document.getElementById('instructionBox4').style.display = 'none';
            document.getElementById('searchInfo').style.display = 'none';

            // Initialize or update DataTable
            if (!tableInitialized) {
                $('#dataTable').DataTable({
                    searching: false,
                    paging: false,
                    info: false,
                    order: [],
                    columnDefs: [{
                        targets: 1,
                        orderData: [1, 2],
                    }]
                });
                tableInitialized = true;
            } else {
                $('#dataTable').DataTable().clear().rows.add($(tableBody).children()).draw();
            }

            saveState();

        } catch (error) {
            console.error("Error parsing CSV file:", error);
            alert("An error occurred while processing the CSV file. Please check the console for details.");
        }
    };

    reader.readAsText(file);
}

function processXLSXFile() {
    const fileInput = document.getElementById('xlsxFileInput');
    const file = fileInput.files[0];
    if (!file) {
        alert('Please select an Excel file.');
        return;
    }

    // Store the uploaded file name (without the extension) for later use
    uploadedFileName = file.name.replace(/\.[^/.]+$/, ""); // Remove file extension

    const reader = new FileReader();
    reader.onload = function(event) {
        try {
            // Read the Excel file
            const data = new Uint8Array(event.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            
            // Get the first worksheet
            const worksheet = workbook.Sheets[workbook.SheetNames[0]];
            
            // Convert worksheet to JSON
            const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
            
            if (jsonData.length === 0) {
                alert('No data found in the Excel file.');
                return;
            }

            // Get headers from first row and clean them
            const headers = jsonData[0].map(header => 
                String(header).trim().toLowerCase()
            );

            // Validate required headers
            const requiredHeaders = ['channel', 'position', 'unit', 'purpose', 'type', 'dimmer', 'address', 'color', 'gobo', 'accessories'];
            const missingHeaders = requiredHeaders.filter(h => !headers.includes(h));
            
            if (missingHeaders.length > 0) {
                alert(`Missing required headers: ${missingHeaders.join(', ')}`);
                return;
            }

            const tableBody = document.getElementById('tableBody');
            tableBody.innerHTML = ''; // Clear existing rows
            originalData = []; // Clear original data array

            // Process each row (skip header)
            for (let i = 1; i < jsonData.length; i++) {
                const values = jsonData[i];
                if (!values || values.length === 0) continue; // Skip empty rows

                // Create data object using headers as keys
                const rowData = {};
                headers.forEach((header, index) => {
                    rowData[header] = values[index] ? String(values[index]).trim() : '';
                });

                // Parse accessories (assuming they're semicolon-separated)
                const accessories = rowData.accessories ? String(rowData.accessories).split(';').map(acc => ({
                    type: acc.trim()
                })) : [];

                const accessoryText = accessories.map(a => a.type).join(', ');

                // Create table row
                const row = `<tr> 
                    <td>${rowData.channel}</td>
                    <td>${rowData.position}</td>
                    <td>${rowData.unit}</td>
                    <td>${rowData.purpose}</td>
                    <td>${rowData.type}</td>
                    <td>${rowData.dimmer}</td>
                    <td>${rowData.address}</td>
                    <td>${rowData.color}</td>
                    <td>${rowData.gobo}</td>
                    <td>${accessoryText}</td>
                </tr>`;
                tableBody.innerHTML += row;

                // Add to originalData
                originalData.push({
                    channel: rowData.channel,
                    position: rowData.position,
                    unit: rowData.unit,
                    purpose: rowData.purpose,
                    type: rowData.type,
                    dimmer: rowData.dimmer,
                    address: rowData.address,
                    color: rowData.color,
                    gobo: rowData.gobo,
                    accessories
                });
            }

            // Update UI
            document.getElementById('dataTable').style.display = 'block';
            document.getElementById('instructionBox').style.display = 'none';
            document.getElementById('instructionBox2').style.display = 'none';
            document.getElementById('instructionBox3').style.display = 'none';
            document.getElementById('instructionBox4').style.display = 'none';
            document.getElementById('searchInfo').style.display = 'none';

            // Initialize or update DataTable
            if (!tableInitialized) {
                $('#dataTable').DataTable({
                    searching: false,
                    paging: false,
                    info: false,
                    order: [],
                    columnDefs: [{
                        targets: 1,
                        orderData: [1, 2],
                    }]
                });
                tableInitialized = true;
            } else {
                $('#dataTable').DataTable().clear().rows.add($(tableBody).children()).draw();
            }

            saveState();

        } catch (error) {
            console.error("Error parsing Excel file:", error);
            alert("An error occurred while processing the Excel file. Please check the console for details.");
        }
    };

    reader.readAsArrayBuffer(file);
}

// Add event listener for page load
window.addEventListener('load', () => {
    loadState();
});

// Add event listener for before page unload
window.addEventListener('beforeunload', () => {
    saveState();
});

function compareCSVWithOriginal() {
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.csv, .xlsx';
    
    fileInput.onchange = function(e) {
        const file = e.target.files[0];
        if (!file) {
            alert('Please select a CSV or Excel file.');
            return;
        }

        if (file.name.endsWith('.csv')) {
            processCSVComparison(file);
        } else if (file.name.endsWith('.xlsx')) {
            processExcelComparison(file);
        } else {
            alert('Unsupported file type. Please select a CSV or Excel file.');
        }
    };

    fileInput.click();
}

function processCSVComparison(file) {
    const reader = new FileReader();
    reader.onload = function(event) {
        try {
            const comparisonData = parseCSV(event.target.result);
            compareDifferences(comparisonData);
        } catch (error) {
            console.error("Error comparing CSV file:", error);
            alert("An error occurred while comparing the CSV file. Please check the console for details.");
        }
    };
    reader.readAsText(file);
}

function processExcelComparison(file) {
    const reader = new FileReader();
    reader.onload = function(event) {
        try {
            const data = new Uint8Array(event.target.result);
            const workbook = XLSX.read(data, {type: 'array'});
            const firstSheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[firstSheetName];
            const comparisonData = XLSX.utils.sheet_to_json(worksheet, {header: 1});
            compareDifferences(parseExcel(comparisonData));
        } catch (error) {
            console.error("Error comparing Excel file:", error);
            alert("An error occurred while comparing the Excel file. Please check the console for details.");
        }
    };
    reader.readAsArrayBuffer(file);
}

function parseCSV(csvContent) {
    const lines = csvContent.split('\n');
    const headers = lines[0].split(',').map(header => 
        header.trim().replace(/^["']|["']$/g, '').toLowerCase()
    );
    
    // Convert CSV lines to arrays of values, handling quoted values correctly
    const rows = lines.slice(1).map(line => {
        const values = [];
        let inQuotes = false;
        let currentValue = '';
        
        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            
            if (char === '"') {
                inQuotes = !inQuotes;
            } else if (char === ',' && !inQuotes) {
                values.push(currentValue.trim());
                currentValue = '';
            } else {
                currentValue += char;
            }
        }
        values.push(currentValue.trim()); // Push the last value
        
        return values;
    });

    return parseFileContent(rows, headers);
}

function parseExcel(excelData) {
    const headers = excelData[0].map(header => header.toLowerCase());
    return parseFileContent(excelData.slice(1), headers);
}

function parseFileContent(dataRows, headers) {
    const requiredHeaders = ['channel', 'position', 'unit', 'purpose', 'type', 'dimmer', 'address', 'color', 'gobo', 'accessories'];
    const missingHeaders = requiredHeaders.filter(h => !headers.includes(h));
    
    if (missingHeaders.length > 0) {
        throw new Error(`Missing required headers: ${missingHeaders.join(', ')}`);
    }

    // Filter out empty rows and convert all values to strings
    return dataRows
        .filter(row => Array.isArray(row) && row.some(cell => {
            // Convert to string if possible, otherwise use empty string
            const cellValue = (cell != null) ? String(cell) : '';
            return cellValue.trim() !== '';
        }))
        .map(row => {
            const rowData = {};
            headers.forEach((header, index) => {
                // Convert cell value to string, handling null/undefined
                const cellValue = (row[index] != null) ? String(row[index]) : '';
                rowData[header] = cellValue.trim();
            });
            return rowData;
        });
}

function compareDifferences(comparisonData) {
    const differences = {
        original: [],
        comparison: []
    };

    originalData.forEach(originalRow => {
        const matchingRow = comparisonData.find(compRow => 
            compRow.channel === originalRow.channel &&
            compRow.position === originalRow.position &&
            compRow.unit === originalRow.unit
        );

        if (!matchingRow || hasDifferences(originalRow, matchingRow)) {
            differences.original.push(originalRow);
        }
    });

    comparisonData.forEach(compRow => {
        const matchingRow = originalData.find(origRow => 
            origRow.channel === compRow.channel &&
            origRow.position === compRow.position &&
            origRow.unit === compRow.unit
        );

        if (!matchingRow || hasDifferences(compRow, matchingRow)) {
            differences.comparison.push(compRow);
        }
    });

    displayDifferences(differences);
}

function hasDifferences(row1, row2) {
    const compareFields = ['purpose', 'type', 'dimmer', 'address', 'color', 'gobo', 'accessories'];
    return compareFields.some(field => {
        if (field === 'accessories') {
            const acc1 = Array.isArray(row1.accessories) ? 
                row1.accessories.map(a => a.type).join(';') : row1.accessories;
            const acc2 = Array.isArray(row2.accessories) ? 
                row2.accessories.map(a => a.type).join(';') : row2.accessories;
            return acc1 !== acc2;
        }
        return row1[field] !== row2[field];
    });
}

function displayDifferences(differences) {
    // Create a modal overlay
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: flex-start;
        overflow-y: auto;
        z-index: 1000;
    `;

    // Create the content container
    const content = document.createElement('div');
    content.style.cssText = `
        background: white;
        padding: 20px;
        margin: 20px;
        border-radius: 8px;
        max-width: 95%;
        max-height: 90vh;
        overflow-y: auto;
        position: relative;
    `;

    // Add close and save buttons
    const buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = `
        position: sticky;
        top: 0;
        right: 0;
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        background: white;
        padding: 5px;
        z-index: 2;
    `;

    const saveButton = document.createElement('button');
    saveButton.innerHTML = 'Update';
    saveButton.style.cssText = `
        padding: 5px 10px;
        background: #4CAF50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
    `;

    const closeButton = document.createElement('button');
    closeButton.innerHTML = '';
    closeButton.style.cssText = `
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        padding: 5px;
    `;

    buttonContainer.appendChild(saveButton);
    buttonContainer.appendChild(closeButton);

    // Create arrays to store selected rows
    const selectedRows = new Map();

    // Create the content HTML
    content.innerHTML = `
        <style>
            .diff-table { 
                width: 100%; 
                border-collapse: collapse; 
                margin-bottom: 20px; 
            }
            .diff-table th, .diff-table td { 
                border: 1px solid #ddd; 
                padding: 8px; 
                text-align: left; 
            }
            .diff-table th { 
                background-color: #f2f2f2; 
                position: sticky;
                top: 40px;
                z-index: 1;
            }
            .diff-section { 
                margin-bottom: 30px; 
            }
            h1, h2 { 
                color: #333; 
            }
            .original { 
                background-color: #ffe6e6; 
            }
            .comparison { 
                background-color: #e6ffe6; 
            }
            .selected {
                outline: 2px solid #4CAF50;
            }
            .row-select {
                cursor: pointer;
            }
            .row-select:hover {
                background-color: #f5f5f5;
            }
        </style>
        <h1>Data Comparison Results</h1>
        <p>Click on a row to select which version you want to keep. Selected rows will have a green outline.</p>
        
        <div class="diff-section">
            <h2>Original Data Differences (${differences.original.length} items)</h2>
            <table class="diff-table original">
                <tr>
                    <th>Channel</th>
                    <th>Position</th>
                    <th>Unit</th>
                    <th>Purpose</th>
                    <th>Type</th>
                    <th>Dimmer</th>
                    <th>Address</th>
                    <th>Color</th>
                    <th>Gobo</th>
                    <th>Accessories</th>
                </tr>
                ${differences.original.map((row, index) => `
                    <tr class="row-select" data-type="original" data-index="${index}">
                        <td>${row.channel || ''}</td>
                        <td>${row.position || ''}</td>
                        <td>${row.unit || ''}</td>
                        <td>${row.purpose || ''}</td>
                        <td>${row.type || ''}</td>
                        <td>${row.dimmer || ''}</td>
                        <td>${row.address || ''}</td>
                        <td>${row.color || ''}</td>
                        <td>${row.gobo || ''}</td>
                        <td>${Array.isArray(row.accessories) ? 
                            row.accessories.map(a => a.type).join(', ') : 
                            row.accessories || ''}</td>
                    </tr>
                `).join('')}
            </table>
        </div>

        <div class="diff-section">
            <h2>Comparison Data Differences (${differences.comparison.length} items)</h2>
            <table class="diff-table comparison">
                <tr>
                    <th>Channel</th>
                    <th>Position</th>
                    <th>Unit</th>
                    <th>Purpose</th>
                    <th>Type</th>
                    <th>Dimmer</th>
                    <th>Address</th>
                    <th>Color</th>
                    <th>Gobo</th>
                    <th>Accessories</th>
                </tr>
                ${differences.comparison.map((row, index) => `
                    <tr class="row-select" data-type="comparison" data-index="${index}">
                        <td>${row.channel || ''}</td>
                        <td>${row.position || ''}</td>
                        <td>${row.unit || ''}</td>
                        <td>${row.purpose || ''}</td>
                        <td>${row.type || ''}</td>
                        <td>${row.dimmer || ''}</td>
                        <td>${row.address || ''}</td>
                        <td>${row.color || ''}</td>
                        <td>${row.gobo || ''}</td>
                        <td>${row.accessories || ''}</td>
                    </tr>
                `).join('')}
            </table>
        </div>
    `;

    // Add event listeners for row selection
    content.addEventListener('click', (e) => {
        const row = e.target.closest('.row-select');
        if (row) {
            const type = row.dataset.type;
            const index = parseInt(row.dataset.index);
            const key = `${type}-${index}`;
            
            // Toggle selection
            if (selectedRows.has(key)) {
                selectedRows.delete(key);
                row.classList.remove('selected');
            } else {
                // Find matching row in other table and deselect it
                const matchingData = type === 'original' ? 
                    differences.comparison[index] : differences.original[index];
                if (matchingData) {
                    const matchingKey = `${type === 'original' ? 'comparison' : 'original'}-${index}`;
                    selectedRows.delete(matchingKey);
                    const matchingRow = content.querySelector(`[data-type="${type === 'original' ? 'comparison' : 'original'}"][data-index="${index}"]`);
                    if (matchingRow) matchingRow.classList.remove('selected');
                }
                selectedRows.set(key, { type, index });
                row.classList.add('selected');
            }
        }
    });

    // Add save functionality
    saveButton.onclick = () => {
        // Update original data based on selections
        selectedRows.forEach(({ type, index }) => {
            const selectedData = type === 'original' ? 
                differences.original[index] : 
                differences.comparison[index];

            // Find the index in originalData to update
            const originalIndex = originalData.findIndex(item => 
                item.channel === selectedData.channel &&
                item.position === selectedData.position &&
                item.unit === selectedData.unit
            );

            if (originalIndex !== -1) {
                // Update existing row
                originalData[originalIndex] = { ...selectedData };
            } else {
                // Add new row
                originalData.push({ ...selectedData });
            }
        });

        // Close modal
        document.body.removeChild(modal);
        
        // Update the original table
        updateOriginalTable();
    };

    // Add close functionality
    closeButton.onclick = () => document.body.removeChild(modal);

    // Add close on outside click
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            document.body.removeChild(modal);
        }
    });

    // Add buttons and content to modal
    content.insertBefore(buttonContainer, content.firstChild);
    modal.appendChild(content);

    // Add modal to page
    document.body.appendChild(modal);
}

function updateOriginalTable() {
    const tableBody = document.getElementById('tableBody');
    tableBody.innerHTML = ''; // Clear existing rows

    // Populate the table with updated data
    originalData.forEach(row => {
        const newRow = document.createElement('tr');
        newRow.innerHTML = `
            <td>${row.channel || ''}</td>
            <td>${row.position || ''}</td>
            <td>${row.unit || ''}</td>
            <td>${row.purpose || ''}</td>
            <td>${row.type || ''}</td>
            <td>${row.dimmer || ''}</td>
            <td>${row.address || ''}</td>
            <td>${row.color || ''}</td>
            <td>${row.gobo || ''}</td>
            <td>${Array.isArray(row.accessories) ? 
                row.accessories.map(a => a.type).join(', ') : 
                row.accessories || ''}</td>
        `;
        tableBody.appendChild(newRow);
    });

    // Refresh DataTable
    if ($.fn.DataTable.isDataTable('#dataTable')) {
        $('#dataTable').DataTable().destroy();
    }
    $('#dataTable').DataTable({
        searching: false,
        paging: false,
        info: false,
        order: [],
        columnDefs: [{
            targets: 1,
            orderData: [1, 2],
        }]
    });

    // Save state
    saveState();
}

</script>

</body>
</html>
