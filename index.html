<!--Light Rewrite Web-->
<!--This file is make to help lighting designers and head electrians mimicing some other popular lighting spreadsheet software.-->
<!--This program is free and feel free to use it as you like.-->
<!--Todo List:
Paperwork Exports: add a limit for dynamic way to include longer text. Right now it'll just type ontop of itself.
Layout View: Clean this up, add to savestate, add all paperwork options-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!--Page Info-->
    <title>Light Rewrite</title>
    <link rel="icon" href="lightRewriteIconBlack.ico" type="image/x-icon" id="favicon">
    <script>
        // Function to update favicon based on color scheme
        function updateFavicon() {
            const favicon = document.getElementById('favicon');
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                favicon.href = 'lightRewriteIconWhite.ico';
            } else {
                favicon.href = 'lightRewriteIconBlack.ico';
            }
        }

        // Update favicon initially
        updateFavicon();

        // Listen for theme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', updateFavicon);
    </script>
    <!-- Imports -->
    <link rel="stylesheet" href="https://cdn.datatables.net/1.11.5/css/jquery.dataTables.min.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.datatables.net/1.11.5/js/jquery.dataTables.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <style>
        :root {
            /* Light mode colors */
            --background-color: #ffffff;
            --text-color: #333333;
            --border-color: #dddddd;
            --header-bg: #f2f2f2;
            --table-hover: #f5f5f5;
            --modal-overlay: rgba(0, 0, 0, 0.5);
            --warning-bg: #ffe6e6;
            --modal-bg: #ffffff;
            /* Add these to your existing light mode variables */
            --menu-bg: #f0f0f0;
            --menu-hover: #e0e0e0;
            --dropdown-bg: #ffffff;
            --dropdown-hover: #f1f1f1;
            --menu-shadow: rgba(0, 0, 0, 0.2);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                /* Dark mode colors */
                --background-color: #1a1a1a;
                --text-color: #ffffff;
                --border-color: #444444;
                --header-bg: #2d2d2d;
                --table-hover: #2d2d2d;
                --modal-overlay: rgba(0, 0, 0, 0.7);
                --warning-bg: #662222;
                --modal-bg: #2d2d2d;
                /* Add these to your existing dark mode variables */
                --menu-bg: #2d2d2d;
                --menu-hover: #3d3d3d;
                --dropdown-bg: #1a1a1a;
                --dropdown-hover: #3d3d3d;
                --menu-shadow: rgba(0, 0, 0, 0.4);
            }
        }

        /* Apply variables to existing elements */
        body {
            background-color: var(--background-color);
            color: var(--text-color);
            font-family: Arial, sans-serif; 
            margin: 20px;
            cursor: url('cursor.png'), auto; /* Set custom cursor */ 
        }
        h1 {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .icon {
            width: 30px; /* Adjust size of the icon */
            height: 30px;
            margin: 0 10px; /* Space between text and image */
        }
        .mirrored {
            transform: scaleX(-1); /* Mirroring the right image */
        }
        .menu-bar { 
            background-color: var(--menu-bg); 
            padding: 10px; 
            display: flex; /* Use flex to align items */
            justify-content: flex-start; /* Align items to the left */
            width: 100%; /* Make menu bar full width */
            box-shadow: 0px 2px 5px var(--menu-shadow); /* Add slight shadow for depth */
            margin-bottom: 10px; /* Space below the menu */
        }
        .menu-bar button {
            background-color: var(--menu-bg);
            color: var(--text-color);
            border: none;
            padding: 8px 12px;
            cursor: pointer;
        }
        .menu-bar button:hover {
            background-color: var(--menu-hover);
        }
        .dropdown {
            position: relative; /* Position relative to the menu items */
            margin-right: 15px; /* Space between dropdowns */
        }
        .dropdown:hover .dropdown-content {
            display: block;
        }
        .dropdown-content {
            display: none;
            position: absolute;
            background-color: var(--dropdown-bg);
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px var(--menu-shadow);
            z-index: 1;
        }
        .dropdown-content a {
            color: var(--text-color);
            padding: 8px 12px;
            display: block;
            text-decoration: none;
        }
        .dropdown-content a:hover {
            background-color: var(--dropdown-hover);
        }
        .file-upload, .search-option { margin: 0; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 8px 12px; border: 1px solid #ddd; }
        .instruction { 
            text-align: center; 
            margin-bottom: 20px; 
            font-style: italic; 
            color: #555; 
            display: block; 
        }
        #searchInfo { 
            text-align: center; 
            margin-bottom: 10px; 
            font-weight: bold; 
            color: #007BFF; 
        }
        .diff-table { 
            width: 100%; 
            border-collapse: collapse; 
            margin-bottom: 20px; 
        }
        .diff-table th, .diff-table td { 
            border: 1px solid #ddd; 
            padding: 8px; 
            text-align: left; 
        }
        .diff-table th { 
            background-color: #f2f2f2; 
            position: sticky;
            top: 40px;
            z-index: 1;
        }
        .diff-section { 
            margin-bottom: 30px; 
        }
        h1, h2 { 
            color: #333; 
        }
        .original { 
            background-color: #ffe6e6; 
        }
        .comparison { 
            background-color: #e6ffe6; 
        }
        .selected {
            outline: 2px solid #4CAF50;
        }
        .row-select {
            cursor: pointer;
        }
        .row-select:hover {
            background-color: #f5f5f5;
        }
        .address-table { 
            width: 100%; 
            border-collapse: collapse; 
            margin-top: 20px; 
        }
        .address-table th, .address-table td { 
            border: 1px solid #ddd; 
            padding: 8px; 
            text-align: left; 
        }
        .address-table th { 
            background-color: #f2f2f2; 
            position: sticky;
            top: 40px;
            z-index: 1;
        }
        .address-input {
            width: 80px;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .channel-table { 
            width: 100%; 
            border-collapse: collapse; 
            margin-top: 20px; 
        }
        .channel-table th, .channel-table td { 
            border: 1px solid #ddd; 
            padding: 8px; 
            text-align: left; 
        }
        .channel-table th { 
            background-color: #f2f2f2; 
            position: sticky;
            top: 40px;
            z-index: 1;
        }
        .channel-input {
            width: 80px;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .dimmer-table { 
            width: 100%; 
            border-collapse: collapse; 
            margin-top: 20px; 
        }
        .dimmer-table th, .dimmer-table td { 
            border: 1px solid #ddd; 
            padding: 8px; 
            text-align: left; 
        }
        .dimmer-table th { 
            background-color: #f2f2f2; 
            position: sticky;
            top: 40px;
            z-index: 1;
        }
        .warning {
            background-color: #ffe6e6;
        }
        .modal-content {
            background-color: var(--modal-bg);
            color: var(--text-color);
            padding: 20px;
            margin: 20px;
            border-radius: 8px;
            max-width: 95%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
        }
        input, select {
            background-color: var(--background-color);
            color: var(--text-color);
            border-color: var(--border-color);
        }
        .invalid-input {
            background-color: var(--warning-bg);
        }

        /* DataTables specific styling */
        table.dataTable {
            background-color: var(--background-color);
            color: var(--text-color);
        }

        table.dataTable thead th,
        table.dataTable thead td {
            background-color: var(--header-bg);
            color: var(--text-color);
            border-color: var(--border-color);
        }

        table.dataTable tbody tr {
            background-color: var(--background-color);
            color: var(--text-color);
        }

        table.dataTable tbody tr:hover {
            background-color: var(--table-hover);
        }

        table.dataTable.stripe tbody tr.odd,
        table.dataTable.display tbody tr.odd {
            background-color: var(--background-color);
        }

        table.dataTable.hover tbody tr:hover,
        table.dataTable.display tbody tr:hover {
            background-color: var(--table-hover);
        }

        table.dataTable tbody tr.selected {
            background-color: var(--table-hover);
        }

        table.dataTable.row-border tbody th, 
        table.dataTable.row-border tbody td, 
        table.dataTable.display tbody th, 
        table.dataTable.display tbody td {
            border-color: var(--border-color);
        }

        /* Update the sorting icons background */
        table.dataTable thead .sorting,
        table.dataTable thead .sorting_asc,
        table.dataTable thead .sorting_desc {
            background-color: var(--header-bg);
        }

        /* Base dropdown styles */
        .dropdown {
            position: relative;
            margin-right: 15px;
        }

        .dropdown:hover .dropdown-content {
            display: block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background-color: var(--dropdown-bg);
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px var(--menu-shadow);
            z-index: 1;
        }

        /* Sub-dropdown containers */
        .upload-trigger,
        .check-trigger,
        .export-trigger {
            position: relative;
        }

        /* Sub-dropdown menus */
        .upload-submenu,
        .check-submenu,
        .exports-submenu {
            display: none;
            position: absolute;
            left: 100%;
            top: 0;
            background-color: var(--dropdown-bg);
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px var(--menu-shadow);
            z-index: 2;
        }

        /* Show sub-dropdowns on hover */
        .upload-trigger:hover + .upload-submenu,
        .upload-submenu:hover,
        .check-trigger:hover + .check-submenu,
        .check-submenu:hover,
        .export-trigger:hover + .exports-submenu,
        .exports-submenu:hover {
            display: block;
        }

        /* Links styling */
        .dropdown-content a,
        .upload-submenu a,
        .check-submenu a,
        .exports-submenu a {
            color: var(--text-color);
            padding: 8px 12px;
            text-decoration: none;
            display: block;
            white-space: nowrap;
        }

        /* Hover effects */
        .dropdown-content a:hover,
        .upload-submenu a:hover,
        .check-submenu a:hover,
        .exports-submenu a:hover {
            background-color: var(--dropdown-hover);
        }

        /* Add this CSS to style the sorted column */
        .sorted-column {
            /* Default styles (light mode) */
            background-color: var(--header-bg); /* Use the header background color */
            color: var(--text-color); /* Use the text color */
        }

        @media (prefers-color-scheme: dark) {
            .sorted-column {
                background-color: #000000; /* Black background for dark mode */
                color: #ffffff; /* White text for dark mode */
            }
        }

        @media (prefers-color-scheme: light) {
            .sorted-column {
                background-color: #ffffff; /* White background for light mode */
                color: #000000; /* Black text for light mode */
            }
        }
    </style>
</head>
<body>

    <h1> <!--Title-->
        <picture>
            <source srcset="lightRewriteIconWhite.ico" media="(prefers-color-scheme: dark)">
            <img src="lightRewriteIconBlack.ico" alt="Left Icon" class="icon">
        </picture>
        <span class="title-text">Light Rewrite Web</span>
        <picture>
            <source srcset="lightRewriteIconWhite.ico" media="(prefers-color-scheme: dark)">
            <img src="lightRewriteIconBlack.ico" alt="Right Icon" class="icon mirrored">
        </picture>
    </h1>
    <p class="version" style="font-size: 8px; text-align: right; color: grey;">Version 1.10.9</p>
    <style>
        @media (prefers-color-scheme: light) {
            .title-text {
                background: linear-gradient(45deg, #333333, #666666);
                -webkit-background-clip: text;
                background-clip: text;
                -webkit-text-fill-color: transparent;
            }
        }
        @media (prefers-color-scheme: dark) {
            .title-text {
                background: linear-gradient(45deg, #ffffff, #cccccc);
                -webkit-background-clip: text;
                background-clip: text;
                -webkit-text-fill-color: transparent;
            }
        }
    </style>

<div class="menu-bar"> <!--Menu Bar-->
    <div class="dropdown">
        <button style="border: 1px solid var(--border-color);">File</button>
        <div class="dropdown-content">
            <div class="file-upload">
                <a href="#" class="upload-trigger">Upload -></a>
                <div class="dropdown-content upload-submenu" style="left: 100%; top: 0; display: none;">
                    <label for="fileInput" class="file-upload">
                        <input type="file" id="fileInput" accept=".xml" style="display: none;" onchange="processFile()">
                        <a href="#" onclick="document.getElementById('fileInput').click(); return false;">XML</a>
                    </label>
                    <label for="csvFileInput" class="file-upload">
                        <input type="file" id="csvFileInput" accept=".csv" style="display: none;" onchange="processCSVFile()">
                        <a href="#" onclick="document.getElementById('csvFileInput').click(); return false;">CSV</a>
                    </label>
                    <label for="xlsxFileInput" class="file-upload">
                        <input type="file" id="xlsxFileInput" accept=".xlsx" style="display: none;" onchange="processXLSXFile()">
                        <a href="#" onclick="document.getElementById('xlsxFileInput').click(); return false;">Excel</a>
                    </label>
                </div>
            </div>
            <script>
                const uploadTrigger = document.querySelector('.upload-trigger');
                const uploadSubmenu = document.querySelector('.upload-submenu');

                uploadTrigger.addEventListener('mouseover', function() {
                    uploadSubmenu.style.display = 'block';
                });

                uploadTrigger.addEventListener('mouseleave', function(e) {
                    if (!uploadSubmenu.contains(e.relatedTarget)) {
                        uploadSubmenu.style.display = 'none';
                    }
                });

                uploadSubmenu.addEventListener('mouseleave', function() {
                    uploadSubmenu.style.display = 'none';
                });
            </script>
            <div class="showInfo">
                <a href="#" onclick="getShowInfo()">Show Info</a>
            </div>
            <div class="clearData">
                <a href="#" onclick="clearStoredData()">Reset</a>
            </div>
        </div>
    </div>

    <div class="dropdown">
        <button style="border: 1px solid var(--border-color);">Tools</button>
        <div class="dropdown-content">
            <div class="tools">
                <a href="#" onclick="populateAddressFromDimmer()">Dimmer to Address</a>
            </div>
            <div class="tools">
                <a href="#" onclick="compareCSVWithOriginal()">Compare</a>
            </div>
            <div class="tools">
                <a href="#" class="check-trigger">Error Check -></a>
                <div class="dropdown-content" style="left: 100%; top: 50%; display: none;">
                    <div class="tools">
                        <a href="#" onclick="checkAddresses()">Addresses</a>
                    </div>
                    <div class="tools">
                        <a href="#" onclick="checkChannels()">Channels</a>
                    </div>
                    <div class="tools">
                        <a href="#" onclick="checkDimmerWattage()">Dimmer Load</a>
                    </div>
                    <div class="tools">
                        <a href="#" onclick="checkChannelWattage()">Channel Load</a>
                    </div>
                </div>
                <script>
                    const checkTrigger = document.querySelector('.check-trigger');
                    const errorCheckDropdown = checkTrigger.nextElementSibling;

                    checkTrigger.addEventListener('mouseover', function() {
                        errorCheckDropdown.style.display = 'block';
                    });

                    checkTrigger.addEventListener('mouseleave', function() {
                        errorCheckDropdown.style.display = 'none';
                    });

                    errorCheckDropdown.addEventListener('mouseover', function() {
                        this.style.display = 'block';
                    });

                    errorCheckDropdown.addEventListener('mouseleave', function() {
                        this.style.display = 'none';
                    });
                </script>
            </div>
            <div class="tools">
                <a href="#" class="quick-count-trigger">Quick Count -></a>
                <div class="dropdown-content" style="left: 100%; top: 75%; display: none;">
                    <div class="tools">
                        <a href="#" onclick="quickColor()">Color</a>
                    </div>
                    <div class="tools">
                        <a href="#" onclick="quickInstrument()">Instruments</a>
                    </div>
                </div>
                <script>
                    const quickCountTrigger = document.querySelector('.quick-count-trigger');
                    const quickCountDropdown = quickCountTrigger.nextElementSibling;

                    quickCountTrigger.addEventListener('mouseover', function() {
                        quickCountDropdown.style.display = 'block';
                    });

                    quickCountTrigger.addEventListener('mouseleave', function() {
                        quickCountDropdown.style.display = 'none';
                    });

                    quickCountDropdown.addEventListener('mouseover', function() {
                        this.style.display = 'block';
                    });

                    quickCountDropdown.addEventListener('mouseleave', function() {
                        this.style.display = 'none';
                    });
                </script>
            </div>
        </div>
    </div>

    <div class="dropdown">
        <button style="border: 1px solid var(--border-color);">Views</button>
        <div class="dropdown-content">
            <div class="views">
                <a href="#" onclick="showMainView()">Main</a>
            </div>
            <div class="views">
                <a href="#" onclick="workNoteSpreadsheet()">Work Notes</a>
            </div>
            <div class="views">
                <a href="#" onclick="showAllColumnsView()">All Data</a>
            </div>
            <div class="views">
                <a href="#" onclick="layoutView()">Layout</a>
            </div>
        </div>
    </div>
    
    <div class="dropdown">
        <button style="border: 1px solid var(--border-color);">Search</button>
        <div class="dropdown-content">
            <div class="search-option">
                <a href="#" onclick="searchByChannel()">Channel</a>
            </div>
            <div class="search-option">
                <a href="#" onclick="searchByAddress()">Address</a>
            </div>
            <div class="search-option">
                <a href="#" onclick="searchByPosition()">Position</a>
            </div>
            <div class="search-option">
                <a href="#" onclick="resetSearch()">Reset</a> <!-- Reset option added -->
            </div>
        </div>
    </div>

    <div class="dropdown">
        <button style="border: 1px solid var(--border-color);">Exports</button>
        <div class="dropdown-content">
            <div class="exports">
                <a href="#" class="export-trigger">Paperwork -></a>
                <div class="exports-submenu" style="position: absolute; left: 100%; top: 0; display: none; background-color: var(--dropdown-bg); border: 1px solid var(--border-color); box-shadow: 0px 8px 16px 0px var(--menu-shadow); z-index: 2;">
                    <a href="#" onclick="exportChannelHookup()">Channel Hookup</a>
                    <a href="#" onclick="exportInstrumentSchedule()">Instrument Schedule</a>
                    <a href="#" onclick="exportColorCount()">Color Count</a>
                    <a href="#" onclick="exportInstrumentTypeCount()">Instrument Count</a>
                    <a href="#" onclick="exportWorkNotes()">Work Notes</a>
                </div>
            </div>
            <script>
                const paperworkTrigger = document.querySelector('.export-trigger');
                const paperworkSubmenu = document.querySelector('.exports-submenu');
                
                paperworkTrigger.addEventListener('mouseover', () => {
                    paperworkSubmenu.style.display = 'block';
                });
                
                paperworkTrigger.addEventListener('mouseout', (e) => {
                    if (!paperworkSubmenu.contains(e.relatedTarget)) {
                        paperworkSubmenu.style.display = 'none';
                    }
                });
                
                paperworkSubmenu.addEventListener('mouseleave', () => {
                    paperworkSubmenu.style.display = 'none';
                });
            </script>
            <div class="exports">
                <a href="#" onclick="generatePatchFile()">EOS Patch</a>
            </div>
            <div class="exports">
                <a href="#" onclick="exportTableToCSV()">CSV</a>
            </div>
            <div class="exports">
                <a href="#" onclick="exportAllCategoriesToCSV()">CSV All Data</a>
            </div>
        </div>
    </div>

    <div class="dropdown">
        <button style="border: 1px solid var(--border-color);">Layers</button>
        <div class="dropdown-content" id="layersDropdown">
            <div class="layers">
                <a href="#" onclick="addLayer()">Add Layer</a>
            </div>
        </div>
    </div>
    
    <div class="dropdown">
        <button style="border: 1px solid var(--border-color);">Help</button>
        <div class="dropdown-content">
            <div class="help">
                <a href="https://github.com/MrTutu001/MrTutu001.github.io" target="_blank">GitHub Page</a>
            </div>
            <div class="help">
                <a href="https://github.com/MrTutu001/MrTutu001.github.io/issues" target="_blank">Submit Issue</a>
            </div>
        </div>
    </div>
    
</div>

<div class="instruction" id="instructionBox2" style="color: var(--text-color);">"Perform a complete export on exit" in Vecorworks</div> <!-- Instruction box positioned below the menu -->
<div class="instruction" id="instructionBox" style="color: var(--text-color);">Use the File menu to upload a file.</div> <!-- Instruction box positioned below the menu -->
<div class="instruction" id="instructionBox3" style="color: var(--text-color);">Instructions on how to get XML file:</div> <!-- Instruction box positioned below the menu -->
<div class="instruction" id="instructionBox4" style="color: var(--text-color);">In Vectoworks go: Spotlight > Spotlight Settings > Spotlight Preferences > Lightwright > Use Automatic Lightwright Data Exchange > Perform a complete export on exit > OK</div> <!-- Instruction box positioned below the menu -->


<div id="searchInfo" style="display: none;">Currently Searching: <span id="searchCriteria"></span></div> <!-- Search info box -->

<table id="dataTable" class="display" style="display: none;">
    <thead>
        <tr> <!--Data Point Add-->
            <th>Channel</th>
            <th>Position</th>
            <th>Unit</th>
            <th>Purpose</th>
            <th>Type</th>
            <th>Dimmer</th>
            <th>Address</th>
            <th>Color</th>
            <th>Gobo</th>
            <th>Wattage</th> <!-- Added Wattage header -->
            <th>Accessories</th>
        </tr>
    </thead>
    <tbody id="tableBody">
    </tbody>
</table>

<script>
//Version
const version = 'v1_10_9'
//Globals    
let originalData = []; // Global variable to store original data
let tableInitialized = false; // Keep track of whether the DataTable has been initialized
let instrumentData = []; //Globalize instrumeData?
let uploadedFileName = ''; // Global variable to store the uploaded file name
// Global variables for show information
let showName = '';
let designer = '';
let headElectrician = '';
let workNotesContainer = null;
let workNotesData = []; // This will store our work notes
const workNoteHeaders = ['Channel', 'Position', 'Unit', 'Purpose', 'Type', 'Dimmer', 'Address', 'Color', 'Gobo', 'Wattage', 'Accessories', 'Notes', 'Delete'];
// List of layoutstuff
let layoutLimits = {
    'channel': 12,
    'instrument': 12,
    'gel' : 20,
    'instrCount' : 20,
};


// Add these functions to handle saving/loading state
function saveState() {
    const state = {
        originalData,
        showName,
        designer,
        headElectrician,
        uploadedFileName,
        workNotesData, // Add work notes to saved state
    };
    
    try {
        localStorage.setItem('lightRewriteState', JSON.stringify(state));
    } catch (error) {
        console.error('Error saving state:', error);
    }
}

function loadState() {
    try {
        const savedState = localStorage.getItem('lightRewriteState');
        if (savedState) {
            const state = JSON.parse(savedState);
            
            // Restore all state variables
            originalData = state.originalData || [];
            showName = state.showName || '';
            designer = state.designer || '';
            headElectrician = state.headElectrician || '';
            uploadedFileName = state.uploadedFileName || '';
            workNotesData = state.workNotesData || []; // Load work notes from saved state
            
            // Only update the table if there's data
            if (originalData.length > 0) {
                const tableBody = document.getElementById('tableBody');
                tableBody.innerHTML = '';
                
                originalData.forEach(item => {
                    const accessoriesText = Array.isArray(item.accessories) 
                        ? item.accessories.map(acc => acc.type || acc.inst_type || "Unknown").join("; ")
                        : typeof item.accessories === 'string' 
                            ? item.accessories 
                            : "";

                    const row = `<tr>
                        <td>${item.channel || item.chan || ''}</td>
                        <td>${item.position || item.pos || ''}</td>
                        <td>${item.unit || item.unit_number || ''}</td>
                        <td>${item.purpose || ''}</td>
                        <td>${item.type || item.inst_type || ''}</td>
                        <td>${item.dimmer || ''}</td>
                        <td>${item.address || item.absolute_address || ''}</td>
                        <td>${item.color || ''}</td>
                        <td>${item.gobo || item.template || ''}</td>
                        <td>${item.wattage || ''}</td> <!-- Added Wattage data -->
                        <td>${accessoriesText}</td>
                    </tr>`;
                    tableBody.innerHTML += row;
                });

                document.getElementById('dataTable').style.display = 'block';
                document.getElementById('instructionBox').style.display = 'none';
                document.getElementById('instructionBox2').style.display = 'none';
                document.getElementById('instructionBox3').style.display = 'none';
                document.getElementById('instructionBox4').style.display = 'none';
                document.getElementById('searchInfo').style.display = 'none';

                if (!tableInitialized) {
                    $('#dataTable').DataTable({
                        searching: false,
                        paging: false,
                        info: false,
                        order: [],
                        columnDefs: [{
                            targets: 1,
                            orderData: [1, 2],
                            type: 'num' // Specify that this column should be treated as numeric
                        }],
                        createdRow: function(row, data, dataIndex) {
                            const api = this.api();
                            const sortedColumnIndex = api.order()[0][0]; // Get the index of the sorted column
                            $(row).find('td').eq(sortedColumnIndex).addClass('sorted-column'); // Add class to the sorted column cell
                            // Set the background color to match the system theme
                            $(row).find('td').eq(sortedColumnIndex).css({
                                backgroundColor: 'var(--background-color)', // Match the system theme background color
                                color: 'var(--text-color)' // Match text color
                            });
                        },
                        // Add this to handle the header sorting
                        order: [[0, 'asc']], // Default sorting
                        drawCallback: function(settings) {
                            const api = this.api();
                            const sortedColumnIndex = api.order()[0][0]; // Get the index of the sorted column
                            $(api.column(sortedColumnIndex).header()).addClass('sorted-column'); // Add class to the sorted column header
                            // Update all cells in the sorted column to match the theme
                            api.rows().every(function() {
                                const row = this.node();
                                $(row).find('td').eq(sortedColumnIndex).css({
                                    backgroundColor: 'var(--background-color)', // Match the system theme background color
                                    color: 'var(--text-color)' // Match text color
                                });
                            });
                        }
                    });
                    tableInitialized = true;
                } else {
                    $('#dataTable').DataTable().clear().rows.add($(tableBody).children()).draw();
                }
            }
        }
    } catch (error) {
        console.error('Error loading state:', error);
    }
}

function processFile() {
    const fileInput = document.getElementById('fileInput');
    const file = fileInput.files[0];
    if (!file) {
        alert('Please select an XML file.');
        return;
    }

    // Store the uploaded file name (without the extension) for later use
    uploadedFileName = file.name.replace(/\.[^/.]+$/, ""); // Remove file extension

    const reader = new FileReader();
    reader.onload = function(event) {
        try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(event.target.result, "text/xml");

            const instrumentData = xmlDoc.querySelector("InstrumentData");
            const instruments = instrumentData ? Array.from(instrumentData.children) : [];

            if (instruments.length <= 0) {
                alert("No instrument entries found in the XML file.");
                return;
            }

            const tableBody = document.getElementById('tableBody');
            tableBody.innerHTML = '';
            originalData = [];

            // Start from the 6th instrument (index 5) to skip the first 5
            for (let i = 5; i < instruments.length; i++) {
                const instrument = instruments[i];
                // Create a data object to store ALL properties
                const fullData = {};
                
                // Store all elements as properties
                Array.from(instrument.children).forEach(child => {
                    fullData[child.tagName.toLowerCase()] = child.textContent || '';
                });

                // Parse accessories specifically
                const accessories = [];
                const accessoriesElement = instrument.querySelector('Accessories');
                if (accessoriesElement) {
                    const accessoryItems = Array.from(accessoriesElement.children);
                    for (const accessory of accessoryItems) {
                        const accessoryData = {};
                        Array.from(accessory.children).forEach(child => {
                            accessoryData[child.tagName.toLowerCase()] = child.textContent || '';
                        });
                        accessories.push(accessoryData);
                    }
                }
                fullData.accessories = accessories;

                // Create table row with only the expected columns
                const row = `<tr> 
                    <td>${fullData.channel || ''}</td>
                    <td>${fullData.position || ''}</td>
                    <td>${fullData.unit_number || ''}</td>
                    <td>${fullData.purpose || ''}</td>
                    <td>${fullData.inst_type || ''}</td>
                    <td>${fullData.dimmer || ''}</td>
                    <td>${fullData.absolute_address || ''}</td>
                    <td>${fullData.color || ''}</td>
                    <td>${fullData.template || ''}</td>
                    <td>${fullData.wattage || ''}</td> <!-- Added Wattage data -->
                    <td>${accessories.map(a => a.inst_type || '').join(', ')}</td>
                </tr>`;
                tableBody.innerHTML += row;

                // Store the full data object
                originalData.push(fullData);
            }

            document.getElementById('dataTable').style.display = 'block';
            document.getElementById('instructionBox').style.display = 'none';
            document.getElementById('instructionBox2').style.display = 'none';
            document.getElementById('instructionBox3').style.display = 'none';
            document.getElementById('instructionBox4').style.display = 'none';
            document.getElementById('searchInfo').style.display = 'none';

            // Initialize DataTable with numeric sorting
            if (!tableInitialized) {
                $('#dataTable').DataTable({
                    searching: false,
                    paging: false,
                    info: false,
                    order: [],
                    columnDefs: [
                        {
                            targets: 1, // Adjust this index to the column you want to sort numerically
                            orderData: [1, 2],
                            type: 'num' // Specify that this column should be treated as numeric
                        }
                    ]
                });
                tableInitialized = true;
            } else {
                $('#dataTable').DataTable().clear().rows.add($(tableBody).children()).draw();
            }

            // Apply the theme colors to the newly populated rows
            const api = $('#dataTable').DataTable();
            api.rows().every(function() {
                const row = this.node();
                $(row).find('td').css({
                    backgroundColor: 'var(--background-color)', // Match the system theme background color
                    color: 'var(--text-color)' // Match text color
                });
            });

            saveState();

        } catch (error) {
            console.error("Error parsing XML file:", error);
            alert("An error occurred while processing the XML file. Please check the console for details.");
        }
    };

    reader.readAsText(file);
}

// Function to ask for show information and save it in global variables
function getShowInfo() {
    showName = prompt("Enter the name of the show:", showName || "Unnamed Show");
    designer = prompt("Enter the name of the designer:", designer || "Unknown Designer");
    headElectrician = prompt("Enter the name of the head electrician:", headElectrician || "Unknown Head Electrician");

    // Ensure variables are not empty if user clears them
    showName = showName ? showName : "Unnamed Show";
    designer = designer ? designer : "Unknown Designer";
    headElectrician = headElectrician ? headElectrician : "Unknown Head Electrician";

    saveState();
}

function searchByChannel() {
    const input = prompt("Enter a range (e.g., 1-5) or a list of channel numbers (e.g., 1,2,3):");
    if (input) {
        const filterValues = input.split(',').map(x => x.trim());
        const filteredData = originalData.filter(item => {
            const itemChannel = item.channel || item.chan || '';
            return filterValues.some(value => 
                isInChannelRange(itemChannel, value) || itemChannel === value.trim()
            );
        });

        updateTableWithFilteredData(filteredData, input);
    }
}

function isInChannelRange(channel, input) {
    if (!channel) return false;
    
    const rangePattern = /(\d+)-(\d+)/; // Regex to match ranges like 1-5
    const match = input.match(rangePattern);
    if (match) {
        const start = parseInt(match[1]);
        const end = parseInt(match[2]);
        const channelNum = parseInt(channel);
        return !isNaN(channelNum) && channelNum >= start && channelNum <= end;
    }
    return false;
}

function searchByAddress() {
    const input = prompt("Enter a range (e.g., 100-200) or a list of addresses (e.g., 100,150,200):");
    if (input) {
        const filterValues = input.split(',').map(x => x.trim());
        const filteredData = originalData.filter(item => {
            const itemAddress = item.address || item.absolute_address || '';
            return filterValues.some(value => 
                isInAddressRange(itemAddress, value) || itemAddress === value.trim()
            );
        });

        updateTableWithFilteredData(filteredData, input);
    }
}

function isInAddressRange(address, input) {
    if (!address) return false;
    
    const rangePattern = /(\d+)-(\d+)/; // Regex to match ranges like 100-200
    const match = input.match(rangePattern);
    if (match) {
        const start = parseInt(match[1]);
        const end = parseInt(match[2]);
        const addressNum = parseInt(address);
        return !isNaN(addressNum) && addressNum >= start && addressNum <= end;
    }
    return false;
}

function searchByPosition() {
    const uniquePositions = [...new Set(originalData.map(item => 
        item.position || item.pos || ''
    ).filter(Boolean))]; // Get unique positions, excluding empty values

    // Create the checkboxes dynamically
    let checkboxHTML = uniquePositions.map(position => {
        return `<label><input type="checkbox" value="${position}"> ${position}</label><br>`;
    }).join('');

    // Create a collapsible container for the checkboxes
    const collapsibleHTML = `
        <div class="collapsible-header">
            <h3>Select Positions <span class="toggle-icon">▲</span></h3>
        </div>
        <div class="collapsible-content" style="display: block;">
            ${checkboxHTML}
        </div>
    `;

    // Display the user selection box at the top
    const userSelectionBox = createSelectionBox(collapsibleHTML);
    document.body.insertBefore(userSelectionBox, document.getElementById('dataTable').parentNode);

    // Add collapsible functionality
    const header = userSelectionBox.querySelector('.collapsible-header');
    const content = userSelectionBox.querySelector('.collapsible-content');
    const toggleIcon = userSelectionBox.querySelector('.toggle-icon');

    header.addEventListener('click', () => {
        content.style.display = content.style.display === 'none' ? 'block' : 'none';
        toggleIcon.textContent = content.style.display === 'none' ? '▼' : '▲';
    });

    // Wait for the user to make their selection
    promptUserToSelectPositions(userSelectionBox, checkboxHTML).then(userSelection => {
        if (userSelection) {
            const selectedPositions = userSelection.split(',').map(position => position.trim());
            const filteredData = originalData.filter(item => {
                const itemPosition = item.position || item.pos || '';
                return selectedPositions.includes(itemPosition);
            });

            updateTableWithFilteredData(filteredData, `Positions: ${userSelection}`);
        }
    });

    // Add cancel button
    const cancelButton = document.createElement('button');
    cancelButton.textContent = 'Cancel';
    cancelButton.id = 'cancelSelection';
    cancelButton.style.marginLeft = '10px';
    userSelectionBox.querySelector('button#submitSelection').insertAdjacentElement('afterend', cancelButton);

    cancelButton.addEventListener('click', () => {
        document.body.removeChild(userSelectionBox);
    });
}

// Helper function to update table with filtered data
function updateTableWithFilteredData(filteredData, searchCriteria) {
    const tableBody = document.getElementById('tableBody');
    tableBody.innerHTML = ''; // Clear existing rows

    filteredData.forEach(item => {
        // Extract accessory types into a string
        const accessoriesText = Array.isArray(item.accessories) 
            ? item.accessories.map(acc => acc.type || acc.inst_type || "Unknown").join("; ")
            : typeof item.accessories === 'string' 
                ? item.accessories 
                : "";

        const row = `<tr>
            <td>${item.channel || item.chan || ''}</td>
            <td>${item.position || item.pos || ''}</td>
            <td>${item.unit || item.unit_number || ''}</td>
            <td>${item.purpose || ''}</td>
            <td>${item.type || item.inst_type || ''}</td>
            <td>${item.dimmer || ''}</td>
            <td>${item.address || item.absolute_address || ''}</td>
            <td>${item.color || ''}</td>
            <td>${item.gobo || item.template || ''}</td>
            <td>${item.wattage || ''}</td> <!-- Added Wattage data -->
            <td>${accessoriesText}</td>
        </tr>`;
        tableBody.innerHTML += row;
    });

    $('#dataTable').DataTable().clear().rows.add($(tableBody).children()).draw();
    
    // Display the search criteria
    document.getElementById('searchInfo').style.display = 'block';
    document.getElementById('searchCriteria').innerText = searchCriteria;
}

function createSelectionBox(checkboxHTML) {
    const box = document.createElement('div');
    box.id = 'selectionBox';
    box.innerHTML = `
        <div>${checkboxHTML}</div>
        <button id="submitSelection">Submit</button>
    `;
    return box;
}

function promptUserToSelectPositions(userSelectionBox, checkboxHTML) {
    return new Promise((resolve) => {
        document.getElementById('submitSelection').addEventListener('click', () => {
            const selectedPositions = [...userSelectionBox.querySelectorAll('input[type="checkbox"]:checked')].map(input => input.value);
            resolve(selectedPositions.join(','));

            // Remove the selection box after submission
            document.body.removeChild(userSelectionBox);
        });
    });
}

function resetSearch() {
    const tableBody = document.getElementById('tableBody');
    tableBody.innerHTML = ''; // Clear existing rows

    // Re-add all original data entries
    originalData.forEach(item => {
        // Extract accessory types into a string
        const accessoriesText = Array.isArray(item.accessories) 
            ? item.accessories.map(acc => acc.type || acc.inst_type || "Unknown").join("; ")
            : typeof item.accessories === 'string' 
                ? item.accessories 
                : "";

        const row = `<tr>
            <td>${item.channel || item.chan || ''}</td>
            <td>${item.position || item.pos || ''}</td>
            <td>${item.unit || item.unit_number || ''}</td>
            <td>${item.purpose || ''}</td>
            <td>${item.type || item.inst_type || ''}</td>
            <td>${item.dimmer || ''}</td>
            <td>${item.address || item.absolute_address || ''}</td>
            <td>${item.color || ''}</td>
            <td>${item.gobo || item.template || ''}</td>
            <td>${item.wattage || ''}</td> <!-- Added Wattage data -->
            <td>${accessoriesText}</td>
        </tr>`;
        tableBody.innerHTML += row;
    });

    // Redraw the DataTable
    $('#dataTable').DataTable().clear().rows.add($(tableBody).children()).draw();

    // Hide search info
    document.getElementById('searchInfo').style.display = 'none';
}

function exportChannelHookup() {
    //Check if show info exists
    if (!showName || !designer || !headElectrician) {
        if (confirm('Some show info is missing. Would you like to fill out the missing data?')) {
            getShowInfo();
        }
    }
    function createTableRow(instrument) {
        // Extract accessories with more flexibility
        const accessoriesText = Array.isArray(instrument.accessories) 
            ? instrument.accessories.map(acc => acc.type || acc.inst_type || "Unknown").join("; ")
            : typeof instrument.accessories === 'string' 
                ? instrument.accessories 
                : "";

        // Extract dimmer information
        const dimmerText = instrument.dimmer || instrument.dimmer_number || '';

        return `<div style="display: flex; justify-content: space-between; margin-bottom: 10px; width: 100%;">
            <span style="width: 12%;">${instrument.channel || instrument.chan || ''}</span>
            <span style="width: 12%;">${instrument.position || instrument.pos || ''}</span>
            <span style="width: 12%;">${instrument.unit || instrument.unit_number || ''}</span>
            <span style="width: 12%;">${instrument.purpose || ''}</span>
            <span style="width: 12%;">${instrument.type || instrument.inst_type || ''}</span>
            <span style="width: 12%;">${dimmerText}</span> <!-- Added Dimmer data -->
            <span style="width: 12%;">${instrument.address || instrument.absolute_address || ''}</span>
            <span style="width: 12%;">${instrument.color || ''}</span>
            <span style="width: 12%;">${instrument.gobo || instrument.template || ''}</span>
            <span style="width: 12%;">${instrument.wattage || ''}</span> <!-- Added Wattage data -->
            <span style="width: 12%;">${accessoriesText}</span>
        </div>
        <hr style="margin: 5px 0; border: none; border-top: 1px solid #000;"/>`;
    }

    function createHeader(pageNumber) { //Data Point Add
        return `
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                <h1 style="margin: 0; color: black;">Channel Hookup - ${showName}</h1>
                <div style="text-align: center; font-size: 10px; color: black;">Designer: ${designer} | HE: ${headElectrician}</div>
                <div style="text-align: right; font-size: 10px; color: black;">Page ${pageNumber}...</div>
            </div>
            <div style="font-weight: bold; display: flex; justify-content: space-between; width: 100%;">
                <span style="width: 12%;">Channel</span>
                <span style="width: 12%;">Position</span>
                <span style="width: 12%;">Unit</span>
                <span style="width: 12%;">Purpose</span>
                <span style="width: 12%;">Type</span>
                <span style="width: 12%;">Dimmer</span> <!-- Added Dimmer header -->
                <span style="width: 12%;">Address</span>
                <span style="width: 12%;">Color</span>
                <span style="width: 12%;">Gobo</span>
                <span style="width: 12%;">Wattage</span> <!-- Added Wattage header -->
                <span style="width: 12%;">Accessories</span>
            </div>
            <hr style="margin: 5px 0; border: none; border-top: 1px solid #000;"/>
        `;
    }

    function createFooter(pageNumber) {
        return `
            <div style="text-align: center; font-size: 8px; margin-top: 20px; color: black;">
                <p>This was generated using Light Rewrite Web ${version}</p>
            </div>
        `;
    }

    const data = originalData.sort((a, b) => {
        const channelA = parseInt(a.channel) || 0;
        const channelB = parseInt(b.channel) || 0;
        return channelA - channelB;
    }).filter(item => item.channel || item.chan); // Filter out items without a channel value

    if (data.length === 0) {
        alert('No instrument data available for export.');
        return;
    }

    const pdfDiv = document.createElement('div');
    pdfDiv.style.width = '100%';
    pdfDiv.style.fontSize = '12px';
    pdfDiv.style.color = 'black'; // Ensure text is always black

    const instrumentsPerPage = layoutLimits.channel;
    let pageNumber = 1;

    for (let i = 0; i < data.length; i += instrumentsPerPage) {
        const chunk = data.slice(i, i + instrumentsPerPage);
        const headerContent = createHeader(pageNumber);

        let pdfContent = '';
        chunk.forEach((instrument) => {
            pdfContent += createTableRow(instrument);
        });

        const footerContent = createFooter(pageNumber);
        pdfContent += footerContent; // Add footer content to the last page

        pdfDiv.innerHTML += headerContent + pdfContent;

        if (i + instrumentsPerPage < data.length) {
            pdfDiv.innerHTML += '<div style="page-break-after: always;"></div>';
        }

        pageNumber++;
    }

    // Check if any channels were excluded
    const totalChannels = originalData.length;
    const filteredChannels = data.length;
    const excludedChannels = totalChannels - filteredChannels;
    if (excludedChannels > 0) {
        const confirmation = confirm(`Warning: ${excludedChannels} instruments will not be included due to missing channels. Do you want to continue?`);
        if (!confirmation) {
            return;
        }
    }

    // Display a message to the user that the file is processing
    const processingMessage = document.createElement('div');
    processingMessage.style.position = 'fixed';
    processingMessage.style.top = '50%';
    processingMessage.style.left = '50%';
    processingMessage.style.transform = 'translate(-50%, -50%)';
    processingMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
    processingMessage.style.color = 'white';
    processingMessage.style.padding = '20px';
    processingMessage.style.borderRadius = '10px';
    processingMessage.style.zIndex = '9999';
    processingMessage.innerHTML = 'Processing your PDF file. This may take a few minuites...';
    document.body.appendChild(processingMessage);
    setTimeout(() => {
        document.body.removeChild(processingMessage);
    }, 2000);

    const pdfOptions = {
        margin:       0.5,
        filename:     `${uploadedFileName}_channel_hookup.pdf`,
        image:        { type: 'jpeg', quality: 0.98 },
        html2canvas:  { scale: 2 },
        jsPDF:        { unit: 'in', format: 'letter', orientation: 'landscape' }
    };

    html2pdf().from(pdfDiv).set(pdfOptions).save();
}

function exportInstrumentSchedule() {
    //Check if show info exists
    if (!showName || !designer || !headElectrician) {
        if (confirm('Some show info is missing. Would you like to fill out the missing data?')) {
            getShowInfo();
        }
    }
    function createTableRow(instrument) {
        // Extract accessories with more flexibility
        const accessoriesText = Array.isArray(instrument.accessories) 
            ? instrument.accessories.map(acc => acc.type || acc.inst_type || "Unknown").join("; ")
            : typeof instrument.accessories === 'string' 
                ? instrument.accessories 
                : "";

        // Extract dimmer information
        const dimmerText = instrument.dimmer || instrument.dimmer_number || '';

        return `<div style="display: flex; justify-content: space-between; margin-bottom: 10px; width: 100%;">
            <span style="width: 12%;">${instrument.unit || instrument.unit_number || ''}</span>
            <span style="width: 12%;">${instrument.purpose || ''}</span>
            <span style="width: 12%;">${instrument.type || instrument.inst_type || ''}</span>
            <span style="width: 12%;">${instrument.channel || instrument.chan || ''}</span>
            <span style="width: 12%;">${dimmerText}</span> <!-- Added Dimmer data -->
            <span style="width: 12%;">${instrument.address || instrument.absolute_address || ''}</span>
            <span style="width: 12%;">${instrument.color || ''}</span>
            <span style="width: 12%;">${instrument.gobo || instrument.template || ''}</span>
            <span style="width: 12%;">${instrument.wattage || ''}</span> <!-- Added Wattage data -->
            <span style="width: 12%;">${accessoriesText}</span>
        </div>
        <hr style="margin: 5px 0; border: none; border-top: 1px solid #000;"/>`;
    }

    function createHeader(position, pageNumber) { //Data Point Add
        return `
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                <h1 style="margin: 0; color: black;">Instrument Schedule - ${showName}</h1>
                <div style="text-align: center; font-size: 10px; color: black;">Designer: ${designer} | HE: ${headElectrician}</div>
                <div style="text-align: right; font-size: 10px; color: black;">Page ${pageNumber}...</div>
            </div>
            <div style="text-align: left; font-size: 15px; font-weight: bold; color: black;">Position: ${position}</div>
            <div style="font-weight: bold; display: flex; justify-content: space-between; width: 100%; margin-top: 10px;">
                <span style="width: 12%;">Unit</span>
                <span style="width: 12%;">Purpose</span>
                <span style="width: 12%;">Type</span>
                <span style="width: 12%;">Channel</span>
                <span style="width: 12%;">Dimmer</span> <!-- Added Dimmer header -->
                <span style="width: 12%;">Address</span>
                <span style="width: 12%;">Color</span>
                <span style="width: 12%;">Gobo</span>
                <span style="width: 12%;">Wattage</span> <!-- Added Wattage header -->
                <span style="width: 12%;">Accessories</span>
            </div>
            <hr style="margin: 5px 0; border: none; border-top: 1px solid #000;"/>
        `;
    }

    function createFooter(pageNumber) {
        return `
            <div style="text-align: center; font-size: 8px; margin-top: 20px; color: black;">
                <p>This was generated using Light Rewrite Web ${version}</p>
            </div>
        `;
    }

    const data = originalData.sort((a, b) => {
        if (a.position === b.position) {
            // Handle cases where unit might be in either unit or unit_number field
            const unitA = a.unit || a.unit_number || '0';
            const unitB = b.unit || b.unit_number || '0'; 
            // Separate numeric and alphabetic parts
            const regex = /(\d+)(\D*)/; // Match numbers followed by letters
            const matchA = unitA.match(regex);
            const matchB = unitB.match(regex);
            const numA = matchA ? parseInt(matchA[1], 10) : 0; // Numeric part
            const numB = matchB ? parseInt(matchB[1], 10) : 0; // Numeric part
            const alphaA = matchA ? matchA[2] : ''; // Alphabetic part
            const alphaB = matchB ? matchB[2] : ''; // Alphabetic part
            
            // First compare numerically
            if (numA !== numB) {
                return numA - numB; // Sort numerically
            }
            // If numbers are the same, sort alphabetically
            return alphaA.localeCompare(alphaB);
        }
        return (a.position || '').localeCompare(b.position || '');
    });

    if (data.length === 0) {
        alert('No instrument data available for export.');
        return;
    }

    const pdfDiv = document.createElement('div');
    pdfDiv.style.width = '100%';
    pdfDiv.style.fontSize = '12px';
    pdfDiv.style.color = 'black'; // Ensure text is always black

    const instrumentsPerPage = layoutLimits.instrument; // Limit to 15 instruments per page
    let pageNumber = 1;
    let lastPosition = ''; // Track the last position to detect changes
    let instrumentsInPosition = 0; // Track the number of instruments on the current page

    // Check for instruments with empty position and warn the user
    const instrumentsWithEmptyPosition = data.filter(instrument => !instrument.position);
    if (instrumentsWithEmptyPosition.length > 0) {
        const response = confirm(`Warning: ${instrumentsWithEmptyPosition.length} instruments with empty position will not be included in the PDF. Proceed?`);
        if (!response) {
            return; // Cancel the function if the user chooses not to proceed
        }
    }

    for (let i = 0; i < data.length; i++) {
        const instrument = data[i];
        if (!instrument.position) {
            continue; // Skip instruments with unknown position
        }

        // If the position is different, or we have reached the instrument limit per page, 
        // add a page break and reset the instrument count
        if (instrument.position !== lastPosition || instrumentsInPosition === instrumentsPerPage) {
            // If it's not the first position, add a page break
            if (lastPosition !== '') {
                pdfDiv.innerHTML += '<div style="page-break-after: always;"></div>';
            }

            // Add the header for the new position
            pdfDiv.innerHTML += createHeader(instrument.position, pageNumber);
            lastPosition = instrument.position; // Update last position
            instrumentsInPosition = 0; // Reset counter for instruments

            pageNumber++; // Increment page number
        }

        // Add the instrument to the page
        pdfDiv.innerHTML += createTableRow(instrument);

        // Increment instrument count for the current page
        instrumentsInPosition++;
         // If we have reached the limit for the page, insert a page break and footer
         if (instrumentsInPosition === instrumentsPerPage) {
            // Add the footer at the bottom of the page after the instruments
            pdfDiv.innerHTML += createFooter(pageNumber);
        }

        // If it's the last instrument for this position or last in data, insert the page break
        if ((i === data.length - 1 || data[i + 1].position !== instrument.position) && instrumentsInPosition !== instrumentsPerPage) {
            const footerContent = createFooter(pageNumber);
            pdfDiv.innerHTML += footerContent;
        }
    }

    // Display a message to the user that the file is processing
    const processingMessage = document.createElement('div');
    processingMessage.style.position = 'fixed';
    processingMessage.style.top = '50%';
    processingMessage.style.left = '50%';
    processingMessage.style.transform = 'translate(-50%, -50%)';
    processingMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
    processingMessage.style.color = 'white';
    processingMessage.style.padding = '20px';
    processingMessage.style.borderRadius = '10px';
    processingMessage.style.zIndex = '9999';
    processingMessage.innerHTML = 'Processing your PDF file. This may take a few minuites...';
    document.body.appendChild(processingMessage);
    setTimeout(() => {
        document.body.removeChild(processingMessage);
    }, 2000);

    const pdfOptions = {
        margin:       0.5,
        filename:     `${uploadedFileName}_instrument_schedule.pdf`,
        image:        { type: 'jpeg', quality: 0.98 },
        html2canvas:  { scale: 2 },
        jsPDF:        { unit: 'in', format: 'letter', orientation: 'landscape' }
    };

    html2pdf().from(pdfDiv).set(pdfOptions).save();
}

function exportColorCount() {
    //Check if show info exists
    if (!showName || !designer || !headElectrician) {
        if (confirm('Some show info is missing. Would you like to fill out the missing data?')) {
            getShowInfo();
        }
    }
    function createHeader(pageNumber) { //Data Point Add
        return `
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                <h1 style="margin: 0; color: black;">Color Count ${showName}</h1>
                <div style="text-align: center; font-size: 10px; color: black;">Designer: ${designer} | HE: ${headElectrician}</div>
                <div style="text-align: right; font-size: 10px; color: black;">Page ${pageNumber}...</div>
            </div>
            <div style="font-weight: bold; display: flex; justify-content: space-between; width: 100%;">
                <span style="width: 45%;">Color</span>
                <span style="width: 45%;">Instrument Type</span>
                <span style="width: 10%;">Count</span>
            </div>
            <hr style="margin: 5px 0; border: none; border-top: 1px solid #000;"/>
        `;
    }

    function createFooter(pageNumber) {
        return `
            <div style="text-align: center; font-size: 8px; margin-top: 20px; color: black;">
                <p>This was generated using Light Rewrite Web ${version}</p>
            </div>
        `;
    }

    // Create a map to count colors by instrument type (using "type" field)
    const colorCount = {};

    originalData.forEach(instrument => {
        let colors = [];
        if (instrument.color.startsWith("User")) {
            const userNumber = instrument.color.split(" ")[1];
            colors = instrument[`user_field_${userNumber}`].split(/[+,]/).map(color => color.trim());  // Split colors if multiple, using comma or plus sign
        } else {
            colors = instrument.color.split(/[+,]/).map(color => color.trim());  // Split colors if multiple, using comma or plus sign
        }
        const instType = instrument.type || instrument.inst_type || "Unknown";  // Add fallback for inst_type

        // Debugging: Log the inst_type and color for each instrument
        console.log(`Instrument: ${instrument.channel}, Colors: ${colors.join(', ')}, Instrument Type: ${instType}`);

        colors.forEach(color => {
            if (color) { // Check if color is not empty
                if (!colorCount[color]) {
                    colorCount[color] = {};
                }

                if (!colorCount[color][instType]) {
                    colorCount[color][instType] = 0;
                }

                colorCount[color][instType]++;
            }
        });
    });

    // Flatten the colorCount object into an array for easy PDF generation
    const colorReport = [];
    for (const color in colorCount) {
        if (color !== "Unknown") { // Exclude "Unknown" color
            for (const instType in colorCount[color]) {
                colorReport.push({
                    color: color,
                    instType: instType,
                    count: colorCount[color][instType]
                });
            }
        }
    }

    // Function to extract the letter prefix (R, L, G, etc.)
    function getPrefix(color) {
        return color.charAt(0);
    }

    // Function to extract the numeric part and normalize it
    function getNormalizedNumber(color) {
        if (color === "N/C") return Infinity; // Ensure "N/C" is always at the bottom

        let prefix = getPrefix(color);
        let numberPart = color.slice(1); // Remove the leading letter

        // If the prefix is 'R' and the number starts with '3', remove the leading '3'
        if (prefix === 'R' && numberPart.length === 3 && numberPart.startsWith('3')) {
            numberPart = numberPart.slice(1);
        }

        return parseInt(numberPart, 10); // Convert to integer for proper numeric sorting
    }

    // Sort the report
    colorReport.sort((a, b) => {
        // Handle "N/C" to always be at the bottom
        if (a.color === "N/C") return 1;
        if (b.color === "N/C") return -1;

        let prefixA = getPrefix(a.color);
        let prefixB = getPrefix(b.color);

        // First, sort by the prefix (letter at the start)
        if (prefixA !== prefixB) {
            return prefixA.localeCompare(prefixB);
        }

        // If prefixes are the same, sort by the normalized numeric value
        return getNormalizedNumber(a.color) - getNormalizedNumber(b.color);
    });



    if (colorReport.length === 0) {
        alert('No color data available for export.');
        return;
    }

    const pdfDiv = document.createElement('div');
    pdfDiv.style.width = '100%';
    pdfDiv.style.fontSize = '12px';
    pdfDiv.style.color = 'black'; // Ensure text is always black

    const itemsPerPage = layoutLimits.gel;
    let pageNumber = 1;

    for (let i = 0; i < colorReport.length; i += itemsPerPage) {
        const chunk = colorReport.slice(i, i + itemsPerPage);
        const headerContent = createHeader(pageNumber);

        let pdfContent = '';
        chunk.forEach((report) => {
            pdfContent += `<div style="display: flex; justify-content: space-between; margin-bottom: 10px; width: 100%;">
                <span style="width: 45%;">${report.color}</span>
                <span style="width: 45%;">${report.instType}</span>
                <span style="width: 10%;">${report.count}</span>
            </div>
            <hr style="margin: 5px 0; border: none; border-top: 1px solid #000;"/>`;
        });

        const footerContent = createFooter(pageNumber);
        pdfDiv.innerHTML += headerContent + pdfContent + footerContent;

        if (i + itemsPerPage < colorReport.length) {
            pdfDiv.innerHTML += '<div style="page-break-after: always;"></div>';
        }

        pageNumber++;
    }

    // Display a message to the user that the file is processing
    const processingMessage = document.createElement('div');
    processingMessage.style.position = 'fixed';
    processingMessage.style.top = '50%';
    processingMessage.style.left = '50%';
    processingMessage.style.transform = 'translate(-50%, -50%)';
    processingMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
    processingMessage.style.color = 'white';
    processingMessage.style.padding = '20px';
    processingMessage.style.borderRadius = '10px';
    processingMessage.style.zIndex = '9999';
    processingMessage.innerHTML = 'Processing your PDF file. This may take a few minuites...';
    document.body.appendChild(processingMessage);
    setTimeout(() => {
        document.body.removeChild(processingMessage);
    }, 2000);

    const pdfOptions = {
        margin:       0.5,
        filename:     `${uploadedFileName}_color_count.pdf`,
        image:        { type: 'jpeg', quality: 0.98 },
        html2canvas:  { scale: 2 },
        jsPDF:        { unit: 'in', format: 'letter', orientation: 'landscape' }
    };

    html2pdf().from(pdfDiv).set(pdfOptions).save();
}

function exportInstrumentTypeCount() {
    //Check if show info exists
    if (!showName || !designer || !headElectrician) {
        if (confirm('Some show info is missing. Would you like to fill out the missing data?')) {
            getShowInfo();
        }
    }
    function createHeader(pageNumber) {
        return `
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px; color: black;">
                <h1 style="margin: 0;">Instrument Type Count ${showName}</h1>
                <div style="text-align: center; font-size: 10px;">Designer: ${designer} | HE: ${headElectrician}</div>
                <div style="text-align: right; font-size: 10px;">Page ${pageNumber}...</div>
            </div>
            <div style="font-weight: bold; display: flex; justify-content: space-between; width: 100%; color: black;">
                <span style="width: 80%;">Instrument Type</span>
                <span style="width: 20%;">Count</span>
            </div>
            <hr style="margin: 5px 0; border: none; border-top: 1px solid #000;"/>
        `;
    }

    function createFooter(pageNumber) {
        return `
            <div style="text-align: center; font-size: 8px; margin-top: 20px; color: black;">
                <p>This was generated using Light Rewrite Web ${version}</p>
            </div>
        `;
    }

    // Create a map to count the instrument types
    const typeCount = {};

    originalData.forEach(instrument => {
        const instType = instrument.type || instrument.inst_type || "Unknown";  // Add fallback for inst_type

        // Debugging: Log the instrument type for each instrument
        console.log(`Instrument: ${instrument.channel}, Instrument Type: ${instType}`);

        if (!typeCount[instType]) {
            typeCount[instType] = 0;
        }

        typeCount[instType]++;
    });

    // Convert the typeCount object into an array for easy PDF generation
    const typeReport = [];
    let totalInstrumentCount = 0; // Initialize total instrument count
    for (const instType in typeCount) {
        typeReport.push({
            instType: instType,
            count: typeCount[instType]
        });
        totalInstrumentCount += typeCount[instType]; // Accumulate total instrument count
    }

    // Sort the report alphabetically by instrument type
    typeReport.sort((a, b) => a.instType.localeCompare(b.instType));

    if (typeReport.length === 0) {
        alert('No instrument type data available for export.');
        return;
    }

    const pdfDiv = document.createElement('div');
    pdfDiv.style.width = '100%';
    pdfDiv.style.fontSize = '12px';

    const itemsPerPage = layoutLimits.instrCount;
    let pageNumber = 1;

    for (let i = 0; i < typeReport.length; i += itemsPerPage) {
        const chunk = typeReport.slice(i, i + itemsPerPage);
        const headerContent = createHeader(pageNumber);

        let pdfContent = '';
        chunk.forEach((report) => {
            pdfContent += `<div style="display: flex; justify-content: space-between; margin-bottom: 10px; width: 100%; color: black;">
                <span style="width: 80%;">${report.instType}</span>
                <span style="width: 20%;">${report.count}</span>
            </div>
            <hr style="margin: 5px 0; border: none; border-top: 1px solid #000;"/>
        `;
        });

        // Add total instrument count as the last row
        pdfContent += `<div style="display: flex; justify-content: space-between; margin-bottom: 10px; width: 100%; font-weight: bold; color: black;">
                <span style="width: 80%;">Total Instruments</span>
                <span style="width: 20%;">${totalInstrumentCount}</span>
            </div>`;

        const footerContent = createFooter(pageNumber);
        pdfDiv.innerHTML += headerContent + pdfContent + footerContent;

        if (i + itemsPerPage < typeReport.length) {
            pdfDiv.innerHTML += '<div style="page-break-after: always;"></div>';
        }

        pageNumber++;
    }

    // Display a message to the user that the file is processing
    const processingMessage = document.createElement('div');
    processingMessage.style.position = 'fixed';
    processingMessage.style.top = '50%';
    processingMessage.style.left = '50%';
    processingMessage.style.transform = 'translate(-50%, -50%)';
    processingMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
    processingMessage.style.color = 'white';
    processingMessage.style.padding = '20px';
    processingMessage.style.borderRadius = '10px';
    processingMessage.style.zIndex = '9999';
    processingMessage.innerHTML = 'Processing your PDF file. This may take a few minuites...';
    document.body.appendChild(processingMessage);
    setTimeout(() => {
        document.body.removeChild(processingMessage);
    }, 2000);

    const pdfOptions = {
        margin:       0.5,
        filename:     `${uploadedFileName}_instrument_type_count.pdf`,
        image:        { type: 'jpeg', quality: 0.98 },
        html2canvas:  { scale: 2 },
        jsPDF:        { unit: 'in', format: 'letter', orientation: 'landscape' }
    };

    html2pdf().from(pdfDiv).set(pdfOptions).save();
}

function generatePatchFile() {
    if (!originalData || originalData.length === 0) {
        alert("No data available to generate the patch file.");
        return;
    }

    // Define the headers for the ETC EOS Patch file
    let patchFileContent = "Purpose\tChannel\tAddress\tInstrument Type\tDevice Type\n";

    // Populate each row based on the parsed instrument data
    for (const instrument of originalData) {
        const purpose = instrument.purpose || "N/A";
        const channel = instrument.channel || instrument.chan || "N/A";
        const address = instrument.address || instrument.absolute_address || "N/A";
        const instType = instrument.type || instrument.inst_type || "N/A";
        const deviceType = "Light"; // Static value as per example output

        // Append each row to the content
        patchFileContent += `${purpose}\t${channel}\t${address}\t${instType}\t${deviceType}\n`;
    }

    // Create a blob and download the file
    const blob = new Blob([patchFileContent], { type: "text/plain" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = `${uploadedFileName}_Patch.txt`;
    link.click();
}

function populateAddressFromDimmer() {
    if (!originalData || originalData.length === 0) {
        alert("No data available to populate addresses.");
        return;
    }

    // Prompt the user to input the starting universe for dimmer 1
    let startingUniverse = parseInt(prompt("Enter the starting universe for dimmer 1:", "1"), 10);
    if (isNaN(startingUniverse) || startingUniverse < 1) {
        alert("Invalid universe number. Please enter a valid number starting from 1.");
        return;
    }

    // Loop through each instrument and assign dimmer value to address if address is empty or 0
    for (const instrument of originalData) {
        if ((!instrument.address || instrument.address === "0") && instrument.dimmer) {
            const dimmerValue = parseInt(instrument.dimmer, 10);

            if (!isNaN(dimmerValue) && dimmerValue > 0) {
                // Calculate the correct address using the formula
                const address = dimmerValue + ((startingUniverse - 1) * 512);
                instrument.address = address.toString();
            }
        }
    }
    resetSearch()
}

function exportTableToCSV() {
    // Initialize CSV content with headers
    let csvContent = "Channel,Position,Unit,Purpose,Type,Dimmer,Address,Color,Wattage,Gobo,Accessories\n";

    // Iterate through each instrument in originalData
    for (const instrument of originalData) {
        let row = [
            instrument.channel || instrument.chan || '',  // Handle alternate header names
            instrument.position || instrument.pos || '',
            instrument.unit || instrument.unit_number || '',
            instrument.purpose || '',
            instrument.type || instrument.inst_type || '',
            instrument.dimmer || '',
            instrument.address || instrument.absolute_address || '',
            instrument.color || '',
            instrument.gobo || instrument.template || '',
            instrument.wattage || '', // Added Wattage data
        ];

        // Handle accessories with more flexibility
        let accessories = '';
        if (Array.isArray(instrument.accessories)) {
            accessories = instrument.accessories
                .map(acc => acc.type || acc.inst_type || '')
                .filter(Boolean)
                .join('|');
        } else if (typeof instrument.accessories === 'string') {
            accessories = instrument.accessories;
        }
        row.push(accessories);

        // Escape fields and join into a CSV row
        csvContent += row.map(field => `"${(field + '').replace(/"/g, '""')}"`).join(',') + '\n';
    }

    // Create and trigger download
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.setAttribute('download', `${uploadedFileName}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

function exportAllCategoriesToCSV() {
    // Initialize CSV content with headers
    let csvContent = "";
    let headers = [];

    // Get all unique headers from originalData
    for (const instrument of originalData) {
        for (const key in instrument) {
            if (!headers.includes(key)) {
                headers.push(key);
            }
        }
    }

    // Create CSV headers
    csvContent += headers.join(',') + '\n';

    // Iterate through each instrument in originalData
    for (const instrument of originalData) {
        let row = [];

        // Create a row for each instrument
        for (const header of headers) {
            row.push(instrument[header] || '');
        }

        // Escape fields and join into a CSV row
        csvContent += row.map(field => `"${(field + '').replace(/"/g, '""')}"`).join(',') + '\n';
    }

    // Create and trigger download
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.setAttribute('download', `${uploadedFileName}_AllCategories.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

///Work Notes// Function to create the table and handle auto-fill functionality
function workNoteSpreadsheet() {
    // Hide the original DataTable
    document.getElementById('dataTable').style.display = 'none';

    // Delete all items that have the class: layoutViewInputBox
    const layoutViewInputBoxes = document.querySelectorAll('.layoutViewInputBox');
    layoutViewInputBoxes.forEach(layoutViewInputBox => {
        layoutViewInputBox.remove();
    });
    
    // Create a container for the table if it doesn't exist
    if (!workNotesContainer) {
        workNotesContainer = document.createElement('div');
        workNotesContainer.id = 'workNotesTable';
        workNotesContainer.style.overflowX = 'auto';
        document.body.appendChild(workNotesContainer);
    } else {
        workNotesContainer.style.display = 'block';
        workNotesContainer.innerHTML = ''; // Clear existing content
    }

    // Create and set up table (same as before)
    const table = document.createElement('table');
    table.style.width = '100%';
    table.style.borderCollapse = 'collapse';
    table.style.marginTop = '20px';

    // Create header row with theme-aware styling
    const headerRow = document.createElement('tr');
    workNoteHeaders.forEach(header => {
        const th = document.createElement('th');
        th.innerText = header;
        th.style.border = '1px solid var(--border-color)';
        th.style.padding = '8px';
        th.style.backgroundColor = 'var(--header-bg)';
        th.style.color = 'var(--text-color)';
        headerRow.appendChild(th);
    });
    table.appendChild(headerRow);

    // Restore existing work notes if any exist
    workNotesData.forEach(noteData => {
        const row = createWorkNoteRow(noteData, table);
        table.appendChild(row);
    });

    // Add input row
    const inputRow = createInputRow(table);
    table.appendChild(inputRow);

    // Append table to container
    workNotesContainer.appendChild(table);
    workNotesContainer.style.display = 'block';
    workNotesContainer.scrollIntoView({ behavior: 'smooth' });
}

function createWorkNoteRow(noteData, table) {
    const newRow = document.createElement('tr');
    workNoteHeaders.forEach(header => {
        const td = document.createElement('td');
        td.style.border = '1px solid black';
        td.style.padding = '8px';

        if (header === 'Notes') {
            td.textContent = noteData.notes || '';
        } else if (header === 'Delete') {
            const deleteButton = document.createElement('button');
            deleteButton.innerHTML = '×';
            deleteButton.style.cursor = 'pointer';
            deleteButton.onclick = () => {
                // Remove from DOM
                newRow.remove();
                // Remove from workNotesData array
                const index = workNotesData.findIndex(note => 
                    note.channel === noteData.channel && 
                    note.position === noteData.position && 
                    note.unit === noteData.unit &&
                    note.notes === noteData.notes
                );
                if (index > -1) {
                    workNotesData.splice(index, 1);
                }
            };
            td.appendChild(deleteButton);
        } else {
            td.textContent = noteData[header.toLowerCase()] || '';
        }
        newRow.appendChild(td);
    });
    return newRow;
}

function createInputRow(table) {
    const inputRow = document.createElement('tr');
    const inputCell = document.createElement('td');
    inputCell.colSpan = workNoteHeaders.length;
    inputCell.style.padding = '10px';
    inputCell.style.display = 'flex';
    inputCell.style.gap = '10px';

    // Create select for input type
    const select = document.createElement('select');
    select.style.width = '100px';
    ['Channel', 'Address', 'Dimmer', 'Color'].forEach(opt => {
        const option = document.createElement('option');
        option.value = opt.toLowerCase();
        option.textContent = opt;
        select.appendChild(option);
    });

    // Create input fields
    const searchInput = document.createElement('input');
    searchInput.type = 'text';
    searchInput.style.width = '100px';
    searchInput.placeholder = 'Enter value';

    const notesInput = document.createElement('input');
    notesInput.type = 'text';
    notesInput.style.width = '200px';
    notesInput.placeholder = 'Enter notes';

    // Create add button
    const addButton = document.createElement('button');
    addButton.textContent = 'Add Row';
    addButton.style.backgroundColor = 'var(--dropdown-bg)';
    addButton.style.color = 'var(--text-color)';
    addButton.style.border = '1px solid var(--border-color)';
    addButton.style.cursor = 'pointer';
    addButton.style.padding = '4px 8px';
    addButton.onmouseover = () => {
        addButton.style.backgroundColor = 'var(--dropdown-hover)';
    };
    addButton.onmouseout = () => {
        addButton.style.backgroundColor = 'var(--dropdown-bg)';
    };
    addButton.onclick = () => {
        const searchValue = searchInput.value.trim();
        const notes = notesInput.value.trim();
        if (!searchValue) return;

        // Find matching instruments
        const matchingInstruments = originalData.filter(instrument => {
            const searchField = select.value;
            const instrumentValue = 
                searchField === 'channel' ? (instrument.channel || instrument.chan || '') :
                searchField === 'address' ? (instrument.address || instrument.absolute_address || '') :
                searchField === 'dimmer' ? (instrument.dimmer || '') :
                searchField === 'color' ? (instrument.color || '') : '';
            
            return instrumentValue.toString() === searchValue;
        });

        matchingInstruments.forEach(instrument => {
            // Create note data object
            const noteData = {
                channel: instrument.channel || instrument.chan || '',
                position: instrument.position || instrument.pos || '',
                unit: instrument.unit || instrument.unit_number || '',
                purpose: instrument.purpose || '',
                type: instrument.type || instrument.inst_type || '',
                dimmer: instrument.dimmer || '',
                address: instrument.address || instrument.absolute_address || '',
                color: instrument.color || '',
                gobo: instrument.gobo || instrument.template || '',
                wattage: instrument.wattage || '', // Added Wattage data
                accessories: Array.isArray(instrument.accessories) 
                    ? instrument.accessories.map(acc => acc.type || acc.inst_type || "Unknown").join("; ")
                    : instrument.accessories || '',
                notes: notes
            };

            // Add to workNotesData array
            workNotesData.push(noteData);

            // Create and add row to table
            const newRow = createWorkNoteRow(noteData, table);
            table.insertBefore(newRow, inputRow);
        });

        // Clear inputs after adding
        searchInput.value = '';
        notesInput.value = '';
    };

    // Append all elements to input row
    inputCell.appendChild(select);
    inputCell.appendChild(searchInput);
    inputCell.appendChild(notesInput);
    inputCell.appendChild(addButton);
    inputRow.appendChild(inputCell);

    return inputRow;
}

function handleInput(inputValue, searchType, notes) {
    let matchingData = [];

    switch(searchType) {
        case 'channel':
            matchingData = originalData.filter(item => item.channel === inputValue);
            break;
        case 'address':
            matchingData = originalData.filter(item => item.address === inputValue);
            break;
        case 'dimmer':
            matchingData = originalData.filter(item => item.dimmer === inputValue);
            break;
        case 'color':
            matchingData = originalData.filter(item => 
                item.color && item.color.toLowerCase().includes(inputValue.toLowerCase())
            );
            break;
    }

    if (matchingData.length > 0) {
        matchingData.forEach(rowData => {
            const row = document.createElement('tr');
            
            // Add all data cells first
            workNoteHeaders.forEach(header => {
                const cell = document.createElement('td');
                cell.style.border = '1px solid black';
                cell.style.padding = '8px';
                
                if (header === 'Delete') {
                    // Create delete button
                    const deleteButton = document.createElement('button');
                    deleteButton.innerHTML = '×';
                    deleteButton.style.cursor = 'pointer';
                    deleteButton.style.border = 'none';
                    deleteButton.style.background = 'var(--background-color)';
                    deleteButton.style.color = 'var(--text-color)';
                    deleteButton.style.fontSize = '20px';
                    deleteButton.style.padding = '5px';
                    deleteButton.style.borderRadius = '50%';
                    deleteButton.title = 'Delete Row';
                    
                    // Add hover effect
                    deleteButton.onmouseover = function() {
                        this.style.background = 'var(--dropdown-hover)';
                        this.style.color = 'red';
                    };
                    deleteButton.onmouseout = function() {
                        this.style.background = 'var(--background-color)';
                        this.style.color = 'var(--text-color)';
                    };
                    
                    deleteButton.onclick = function() {
                        row.remove();
                        saveState();
                    };
                    
                    cell.style.width = '30px';
                    cell.style.textAlign = 'center';
                    cell.appendChild(deleteButton);
                } else if (header === 'Notes') {
                    cell.innerText = notes || '';
                } else if (header === 'Accessories' && Array.isArray(rowData.accessories)) {
                    cell.innerText = rowData.accessories.map(acc => acc.type).join(', ') || '';
                } else {
                    cell.innerText = rowData[header.toLowerCase()] || '';
                }
                
                row.appendChild(cell);
            });
            
            // Add delete row button
            const deleteRowCell = document.createElement('td');
            const deleteRowButton = document.createElement('button');
            deleteRowButton.innerHTML = 'Delete Row';
            deleteRowButton.style.cursor = 'pointer';
            deleteRowButton.style.background = 'var(--background-color)';
            deleteRowButton.style.color = 'var(--text-color)';
            deleteRowButton.style.border = '1px solid var(--border-color)';
            deleteRowButton.style.padding = '5px 10px';
            deleteRowButton.style.borderRadius = '5px';
            deleteRowButton.onmouseover = function() {
                this.style.background = 'var(--dropdown-hover)';
            };
            deleteRowButton.onmouseout = function() {
                this.style.background = 'var(--background-color)';
            };
            deleteRowButton.onclick = function() {
                row.remove();
                saveState();
            };
            deleteRowCell.appendChild(deleteRowButton);
            row.appendChild(deleteRowCell);
            
            table.insertBefore(row, table.lastElementChild);
        });
    } else {
        alert(`No fixture found with ${searchType} ${inputValue}`);
    }
}

// Add saveState() calls after table modifications
const originalHandleInput = handleInput;
handleInput = function(...args) {
    originalHandleInput.apply(this, args);
    saveState();
};

function showMainView() {
    // Show the original table
    document.getElementById('dataTable').style.display = 'block';
    
    // Hide work notes if they exist
    if (workNotesContainer) {
        workNotesContainer.style.display = 'none';
    }
    
    // Hide all columns view if it exists
    const allColumnsView = document.getElementById('allColumnsView');
    if (allColumnsView) {
        // Properly destroy the DataTable instance first
        const dynamicTable = $('#dynamicTable');
        if ($.fn.DataTable.isDataTable(dynamicTable)) {
            dynamicTable.DataTable().destroy();
        }
        // Remove the element from the DOM
        allColumnsView.remove();
    }

    // Delete all items that have the class: layoutViewInputBox
    const layoutViewInputBoxes = document.querySelectorAll('.layoutViewInputBox');
    layoutViewInputBoxes.forEach(layoutViewInputBox => {
        layoutViewInputBox.remove();
    });
}

function exportWorkNotes() {
    if (!workNotesContainer || workNotesContainer.style.display === 'none') {
        alert('No work notes available to export.');
        return;
    }

    const rows = Array.from(workNotesContainer.querySelectorAll('tr')).slice(1, -1); // Skip header and input row
    if (rows.length === 0) {
        alert('No work notes to export.');
        return;
    }

    function createHeader(pageNumber) {
        return `
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                <h1 style="margin: 0;">Work Notes ${showName}</h1>
                <div style="text-align: center; font-size: 10px;">Designer: ${designer} | HE: ${headElectrician}</div>
                <div style="text-align: right; font-size: 10px;">Page ${pageNumber}...</div>
            </div>
            <div style="font-weight: bold; display: flex; justify-content: space-between; width: 100%;">
                ${workNoteHeaders.map(header => 
                    `<span style="width: ${header === 'Notes' ? '20%' : '8%'};">${header}</span>`
                ).join('')}
            </div>
            <hr style="margin: 5px 0; border: none; border-top: 1px solid #000;"/>
        `;
    }

    // Rest of exportWorkNotes function remains the same...
}

function clearStoredData() {
    if (confirm('Are you sure you want to clear all stored data? This cannot be undone.')) {
        // Clear localStorage
        localStorage.removeItem('lightRewriteState');
        
        // Reset all global variables
        originalData = [];
        tableInitialized = false;
        instrumentData = [];
        uploadedFileName = '';
        showName = '';
        designer = '';
        headElectrician = '';
        
        // Clear work notes if they exist
        if (workNotesContainer) {
            workNotesContainer.remove();
            workNotesContainer = null;
        }

        // Reset table display
        document.getElementById('dataTable').style.display = 'none';
        document.getElementById('instructionBox').style.display = 'block';
        document.getElementById('instructionBox2').style.display = 'block';
        document.getElementById('instructionBox3').style.display = 'block';
        document.getElementById('instructionBox4').style.display = 'block';
        document.getElementById('searchInfo').style.display = 'none';
        
        // Clear the table body
        document.getElementById('tableBody').innerHTML = '';
        
        // Destroy and reset DataTable if it exists
        if ($.fn.DataTable.isDataTable('#dataTable')) {
            $('#dataTable').DataTable().destroy();
        }
        
        // Reload the page to ensure a clean state
        location.reload();
    }
}

function processCSVFile() {
    const fileInput = document.getElementById('csvFileInput');
    const file = fileInput.files[0];
    if (!file) {
        alert('Please select a CSV file.');
        return;
    }

    // Store the uploaded file name (without the extension) for later use
    uploadedFileName = file.name.replace(/\.[^/.]+$/, ""); // Remove file extension

    const reader = new FileReader();
    reader.onload = function(event) {
        try {
            // Split the CSV content into lines
            const lines = event.target.result.split('\n');
            
            // Get all headers from first line and clean them
            const allHeaders = lines[0].split(',').map(header => 
                header.trim().replace(/^["']|["']$/g, '').toLowerCase()
            );

            const tableBody = document.getElementById('tableBody');
            tableBody.innerHTML = '';
            originalData = [];

            // Process each line (skip header)
            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;

                // Split the line into values and clean them
                const values = lines[i].split(',').map(value => 
                    value.trim().replace(/^["']|["']$/g, '')
                );

                // Create data object with ALL headers
                const fullData = {};
                allHeaders.forEach((header, index) => {
                    fullData[header] = values[index] || '';
                });

                // Parse accessories if present
                const accessories = fullData.accessories ? 
                    fullData.accessories.split(';').map(acc => ({
                        type: acc.trim()
                    })) : [];
                fullData.accessories = accessories;

                // Create table row with only expected columns
                const row = `<tr> 
                    <td>${fullData.channel || ''}</td>
                    <td>${fullData.position || ''}</td>
                    <td>${fullData.unit || ''}</td>
                    <td>${fullData.purpose || ''}</td>
                    <td>${fullData.type || ''}</td>
                    <td>${fullData.dimmer || ''}</td>
                    <td>${fullData.address || ''}</td>
                    <td>${fullData.color || ''}</td>
                    <td>${fullData.gobo || ''}</td>
                    <td>${fullData.wattage || ''}</td> <!-- Added Wattage data -->
                    <td>${accessories.map(a => a.type || '').join(', ')}</td>
                </tr>`;
                tableBody.innerHTML += row;

                // Store the full data object
                originalData.push(fullData);
            }

            // Update UI
            document.getElementById('dataTable').style.display = 'block';
            document.getElementById('instructionBox').style.display = 'none';
            document.getElementById('instructionBox2').style.display = 'none';
            document.getElementById('instructionBox3').style.display = 'none';
            document.getElementById('instructionBox4').style.display = 'none';
            document.getElementById('searchInfo').style.display = 'none';

            // Initialize or update DataTable with sorting enabled for the channel column
            if (!tableInitialized) {
                $('#dataTable').DataTable({
                    searching: false,
                    paging: false,
                    info: false,
                    order: [[0, 'asc']], // Default sorting on channel column
                    columnDefs: [{
                        targets: 1,
                        orderData: [1, 2],
                        type: 'num' // Specify that this column should be treated as numeric
                    }]
                });
                tableInitialized = true;
            } else {
                $('#dataTable').DataTable().clear().rows.add($(tableBody).children()).draw();
            }

            saveState();
            window.location.reload();

        } catch (error) {
            console.error("Error parsing CSV file:", error);
            alert("An error occurred while processing the CSV file. Please check the console for details.");
        }
    };

    reader.readAsText(file);
}

function processXLSXFile() {
    const fileInput = document.getElementById('xlsxFileInput');
    const file = fileInput.files[0];
    if (!file) {
        alert('Please select an Excel file.');
        return;
    }

    // Store the uploaded file name (without the extension) for later use
    uploadedFileName = file.name.replace(/\.[^/.]+$/, ""); // Remove file extension

    const reader = new FileReader();
    reader.onload = function(event) {
        try {
            const data = new Uint8Array(event.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            const worksheet = workbook.Sheets[workbook.SheetNames[0]];
            const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

            if (jsonData.length === 0) {
                alert('No data found in the Excel file.');
                return;
            }

            // Get all headers from first row
            const allHeaders = jsonData[0].map(header => 
                String(header).trim().toLowerCase()
            );

            const tableBody = document.getElementById('tableBody');
            tableBody.innerHTML = '';
            originalData = [];

            // Process each row (skip header)
            for (let i = 1; i < jsonData.length; i++) {
                const values = jsonData[i];
                if (!values || values.length === 0) continue;

                // Create data object with ALL headers
                const fullData = {};
                allHeaders.forEach((header, index) => {
                    fullData[header] = values[index] ? String(values[index]).trim() : '';
                });

                // Parse accessories if present
                const accessories = fullData.accessories ? 
                    String(fullData.accessories).split(';').map(acc => ({
                        type: acc.trim()
                    })) : [];
                fullData.accessories = accessories;

                // Convert channel to number for sorting
                fullData.channel = parseInt(fullData.channel, 10) || 0;

                // Create table row with only expected columns
                const row = `<tr> 
                    <td>${fullData.channel || ''}</td>
                    <td>${fullData.position || ''}</td>
                    <td>${fullData.unit || ''}</td>
                    <td>${fullData.purpose || ''}</td>
                    <td>${fullData.type || ''}</td>
                    <td>${fullData.dimmer || ''}</td>
                    <td>${fullData.address || ''}</td>
                    <td>${fullData.color || ''}</td>
                    <td>${fullData.gobo || ''}</td>
                    <td>${fullData.wattage || ''}</td> <!-- Added Wattage data -->
                    <td>${accessories.map(a => a.type || '').join(', ')}</td>
                </tr>`;
                tableBody.innerHTML += row;

                // Store the full data object
                originalData.push(fullData);
            }

            // Update UI
            document.getElementById('dataTable').style.display = 'block';
            document.getElementById('instructionBox').style.display = 'none';
            document.getElementById('instructionBox2').style.display = 'none';
            document.getElementById('instructionBox3').style.display = 'none';
            document.getElementById('instructionBox4').style.display = 'none';
            document.getElementById('searchInfo').style.display = 'none';

            // Initialize or update DataTable with sorting enabled for the channel column
            if (!tableInitialized) {
                $('#dataTable').DataTable({
                    searching: false,
                    paging: false,
                    info: false,
                    order: [[0, 'asc']], // Default sorting on channel column
                    columnDefs: [{
                        targets: 0, // Channel column
                        orderData: [0], // Use the first column for sorting
                        type: 'num' // Specify that this column should be treated as numeric
                    }]
                });
                tableInitialized = true;
            } else {
                $('#dataTable').DataTable().clear().rows.add($(tableBody).children()).draw();
            }

            saveState();
            window.location.reload();

        } catch (error) {
            console.error("Error parsing Excel file:", error);
            alert("An error occurred while processing the Excel file. Please check the console for details.");
        }
    };

    reader.readAsArrayBuffer(file);
}

// Add event listener for page load
window.addEventListener('load', () => {
    loadState();
});

// Add event listener for before page unload
window.addEventListener('beforeunload', () => {
    saveState();
});

function compareCSVWithOriginal() {
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.csv, .xlsx';
    
    fileInput.onchange = function(e) {
        const file = e.target.files[0];
        if (!file) {
            alert('Please select a CSV or Excel file.');
            return;
        }

        if (file.name.endsWith('.csv')) {
            processCSVComparison(file);
        } else if (file.name.endsWith('.xlsx')) {
            processExcelComparison(file);
        } else {
            alert('Unsupported file type. Please select a CSV or Excel file.');
        }
    };

    fileInput.click();
}

function processCSVComparison(file) {
    const reader = new FileReader();
    reader.onload = function(event) {
        try {
            const comparisonData = parseCSV(event.target.result);
            compareDifferences(comparisonData);
        } catch (error) {
            console.error("Error comparing CSV file:", error);
            alert("An error occurred while comparing the CSV file. Please check the console for details.");
        }
    };
    reader.readAsText(file);
}

function processExcelComparison(file) {
    const reader = new FileReader();
    reader.onload = function(event) {
        try {
            const data = new Uint8Array(event.target.result);
            const workbook = XLSX.read(data, {type: 'array'});
            const firstSheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[firstSheetName];
            const comparisonData = XLSX.utils.sheet_to_json(worksheet, {header: 1});
            compareDifferences(parseExcel(comparisonData));
        } catch (error) {
            console.error("Error comparing Excel file:", error);
            alert("An error occurred while comparing the Excel file. Please check the console for details.");
        }
    };
    reader.readAsArrayBuffer(file);
}

function parseCSV(csvContent) {
    const lines = csvContent.split('\n');
    const headers = lines[0].split(',').map(header => 
        header.trim().replace(/^["']|["']$/g, '').toLowerCase()
    );
    
    // Convert CSV lines to arrays of values, handling quoted values correctly
    const rows = lines.slice(1).map(line => {
        const values = [];
        let inQuotes = false;
        let currentValue = '';
        
        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            
            if (char === '"') {
                inQuotes = !inQuotes;
            } else if (char === ',' && !inQuotes) {
                values.push(currentValue.trim());
                currentValue = '';
            } else {
                currentValue += char;
            }
        }
        values.push(currentValue.trim()); // Push the last value
        
        return values;
    });

    return parseFileContent(rows, headers);
}

function parseExcel(excelData) {
    const headers = excelData[0].map(header => header.toLowerCase());
    return parseFileContent(excelData.slice(1), headers);
}

function parseFileContent(dataRows, headers) {
    const requiredHeaders = ['channel', 'position', 'unit', 'purpose', 'type', 'dimmer', 'address', 'color', 'gobo', 'accessories'];
    const missingHeaders = requiredHeaders.filter(h => !headers.includes(h));
    
    if (missingHeaders.length > 0) {
        throw new Error(`Missing required headers: ${missingHeaders.join(', ')}`);
    }

    // Filter out empty rows and convert all values to strings
    return dataRows
        .filter(row => Array.isArray(row) && row.some(cell => {
            // Convert to string if possible, otherwise use empty string
            const cellValue = (cell != null) ? String(cell) : '';
            return cellValue.trim() !== '';
        }))
        .map(row => {
            const rowData = {};
            headers.forEach((header, index) => {
                // Convert cell value to string, handling null/undefined
                const cellValue = (row[index] != null) ? String(row[index]) : '';
                rowData[header] = cellValue.trim();
            });
            return rowData;
        });
}

function compareDifferences(comparisonData) {
    const differences = {
        original: [],
        comparison: []
    };

    originalData.forEach(originalRow => {
        const matchingRow = comparisonData.find(compRow => 
            compRow.channel === originalRow.channel &&
            compRow.position === originalRow.position &&
            compRow.unit === originalRow.unit
        );

        if (!matchingRow || hasDifferences(originalRow, matchingRow)) {
            differences.original.push(originalRow);
        }
    });

    comparisonData.forEach(compRow => {
        const matchingRow = originalData.find(origRow => 
            origRow.channel === compRow.channel &&
            origRow.position === compRow.position &&
            origRow.unit === compRow.unit
        );

        if (!matchingRow || hasDifferences(compRow, matchingRow)) {
            differences.comparison.push(compRow);
        }
    });

    displayDifferences(differences);
}

function hasDifferences(row1, row2) {
    const compareFields = ['purpose', 'type', 'dimmer', 'address', 'color', 'gobo', 'accessories'];
    return compareFields.some(field => {
        if (field === 'accessories') {
            const acc1 = Array.isArray(row1.accessories) ? 
                row1.accessories.map(a => a.type).join(';') : row1.accessories;
            const acc2 = Array.isArray(row2.accessories) ? 
                row2.accessories.map(a => a.type).join(';') : row2.accessories;
            return acc1 !== acc2;
        }
        return row1[field] !== row2[field];
    });
}

function displayDifferences(differences) {
    // Create a modal overlay
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--modal-overlay);
        display: flex;
        justify-content: center;
        align-items: flex-start;
        overflow-y: auto;
        z-index: 1000;
    `;

    // Create the content container
    const content = document.createElement('div');
    content.style.cssText = `
        background: var(--modal-bg);
        color: var(--text-color);
        padding: 20px;
        margin: 20px;
        border-radius: 8px;
        max-width: 95%;
        max-height: 90vh;
        overflow-y: auto;
        position: relative;
    `;

    // Add close and save buttons
    const buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = `
        position: sticky;
        top: 0;
        right: 0;
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        background: var(--modal-bg);
        padding: 5px;
        z-index: 2;
    `;

    const saveButton = document.createElement('button');
    saveButton.innerHTML = 'Update';
    saveButton.style.cssText = `
        padding: 5px 10px;
        background: #4CAF50;
        color: var(--text-color);
        border: none;
        border-radius: 4px;
        cursor: pointer;
    `;

    const closeButton = document.createElement('button');
    closeButton.innerHTML = '×';
    closeButton.style.cssText = `
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        padding: 5px;
    `;

    buttonContainer.appendChild(saveButton);
    buttonContainer.appendChild(closeButton);

    // Create arrays to store selected rows
    const selectedRows = new Map();

    // Create the content HTML
    content.innerHTML = `
        <style>
            .diff-table { 
                width: 100%; 
                border-collapse: collapse; 
                margin-bottom: 20px; 
            }
            .diff-table th, .diff-table td { 
                border: 1px solid #ddd; 
                padding: 8px; 
                text-align: left; 
            }
            .diff-table th { 
                background-color: #f2f2f2; 
                position: sticky;
                top: 40px;
                z-index: 1;
            }
            .diff-section { 
                margin-bottom: 30px; 
            }
            h1, h2 { 
                color: #333; 
            }
            .original { 
                background-color: #ffe6e6; 
            }
            .comparison { 
                background-color: #e6ffe6; 
            }
            .selected {
                outline: 2px solid #4CAF50;
            }
            .row-select {
                cursor: pointer;
            }
            .row-select:hover {
                background-color: #f5f5f5;
            }
        </style>
        <h1>Data Comparison Results</h1>
        <p>Click on a row to select which version you want to keep. Selected rows will have a green outline.</p>
        
        <div class="diff-section">
            <h2>Original Data Differences (${differences.original.length} items)</h2>
            <table class="diff-table original">
                <tr>
                    <th>Channel</th>
                    <th>Position</th>
                    <th>Unit</th>
                    <th>Purpose</th>
                    <th>Type</th>
                    <th>Dimmer</th>
                    <th>Address</th>
                    <th>Color</th>
                    <th>Gobo</th>
                    <th>Wattage</th> <!-- Added Wattage header -->
                    <th>Accessories</th>
                </tr>
                ${differences.original.map((row, index) => `
                    <tr class="row-select" data-type="original" data-index="${index}">
                        <td>${row.channel || ''}</td>
                        <td>${row.position || ''}</td>
                        <td>${row.unit || ''}</td>
                        <td>${row.purpose || ''}</td>
                        <td>${row.type || ''}</td>
                        <td>${row.dimmer || ''}</td>
                        <td>${row.address || ''}</td>
                        <td>${row.color || ''}</td>
                        <td>${row.gobo || ''}</td>
                        <td>${row.wattage || ''}</td> <!-- Added Wattage data -->
                        <td>${Array.isArray(row.accessories) ? 
                            row.accessories.map(a => a.type).join(', ') : 
                            row.accessories || ''}</td>
                    </tr>
                `).join('')}
            </table>
        </div>

        <div class="diff-section">
            <h2>Comparison Data Differences (${differences.comparison.length} items)</h2>
            <table class="diff-table comparison">
                <tr>
                    <th>Channel</th>
                    <th>Position</th>
                    <th>Unit</th>
                    <th>Purpose</th>
                    <th>Type</th>
                    <th>Dimmer</th>
                    <th>Address</th>
                    <th>Color</th>
                    <th>Gobo</th>
                    <th>Wattage</th> <!-- Added Wattage header -->
                    <th>Accessories</th>
                </tr>
                ${differences.comparison.map((row, index) => `
                    <tr class="row-select" data-type="comparison" data-index="${index}">
                        <td>${row.channel || ''}</td>
                        <td>${row.position || ''}</td>
                        <td>${row.unit || ''}</td>
                        <td>${row.purpose || ''}</td>
                        <td>${row.type || ''}</td>
                        <td>${row.dimmer || ''}</td>
                        <td>${row.address || ''}</td>
                        <td>${row.color || ''}</td>
                        <td>${row.gobo || ''}</td>
                        <td>${row.wattage || ''}</td> <!-- Added Wattage data -->
                        <td>${row.accessories || ''}</td>
                    </tr>
                `).join('')}
            </table>
        </div>
    `;

    // Add event listeners for row selection
    content.addEventListener('click', (e) => {
        const row = e.target.closest('.row-select');
        if (row) {
            const type = row.dataset.type;
            const index = parseInt(row.dataset.index);
            const key = `${type}-${index}`;
            
            // Toggle selection
            if (selectedRows.has(key)) {
                selectedRows.delete(key);
                row.classList.remove('selected');
            } else {
                // Find matching row in other table and deselect it
                const matchingData = type === 'original' ? 
                    differences.comparison[index] : differences.original[index];
                if (matchingData) {
                    const matchingKey = `${type === 'original' ? 'comparison' : 'original'}-${index}`;
                    selectedRows.delete(matchingKey);
                    const matchingRow = content.querySelector(`[data-type="${type === 'original' ? 'comparison' : 'original'}"][data-index="${index}"]`);
                    if (matchingRow) matchingRow.classList.remove('selected');
                }
                selectedRows.set(key, { type, index });
                row.classList.add('selected');
            }
        }
    });

    // Add save functionality
    saveButton.onclick = () => {
        // Update original data based on selections
        selectedRows.forEach(({ type, index }) => {
            const selectedData = type === 'original' ? 
                differences.original[index] : 
                differences.comparison[index];

            // Find the index in originalData to update
            const originalIndex = originalData.findIndex(item => 
                item.channel === selectedData.channel &&
                item.position === selectedData.position &&
                item.unit === selectedData.unit
            );

            if (originalIndex !== -1) {
                // Update existing row
                originalData[originalIndex] = { ...selectedData };
            } else {
                // Add new row
                originalData.push({ ...selectedData });
            }
        });

        // Close modal
        document.body.removeChild(modal);
        
        // Update the original table
        updateOriginalTable();
    };

    // Add close functionality
    closeButton.onclick = () => document.body.removeChild(modal);

    // Add close on outside click
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            document.body.removeChild(modal);
        }
    });

    // Add buttons and content to modal
    content.insertBefore(buttonContainer, content.firstChild);
    modal.appendChild(content);

    // Add modal to page
    document.body.appendChild(modal);
}

function updateOriginalTable() {
    const tableBody = document.getElementById('tableBody');
    tableBody.innerHTML = ''; // Clear existing rows

    // Populate the table with updated data
    originalData.forEach(row => {
        const newRow = document.createElement('tr');
        newRow.innerHTML = `
            <td>${row.channel || ''}</td>
            <td>${row.position || ''}</td>
            <td>${row.unit || ''}</td>
            <td>${row.purpose || ''}</td>
            <td>${row.type || ''}</td>
            <td>${row.dimmer || ''}</td>
            <td>${row.address || ''}</td>
            <td>${row.color || ''}</td>
            <td>${row.gobo || ''}</td>
            <td>${row.wattage || ''}</td> <!-- Added Wattage data -->
            <td>${Array.isArray(row.accessories) ? 
                row.accessories.map(a => a.type).join(', ') : 
                row.accessories || ''}</td>
        `;
        tableBody.appendChild(newRow);
    });

    // Refresh DataTable
    if ($.fn.DataTable.isDataTable('#dataTable')) {
        $('#dataTable').DataTable().destroy();
    }
    $('#dataTable').DataTable({
        searching: false,
        paging: false,
        info: false,
        order: [],
        columnDefs: [{
            targets: 1,
            orderData: [1, 2],
        }]
    });

    // Save state
    saveState();
}

// Add this new function
function showAllColumnsView() {
    // Check for existing view first
    let existingView = document.getElementById('allColumnsView');
    if (existingView) {
        existingView.remove(); // Remove existing view if it exists
    }

    // Hide other views
    document.getElementById('dataTable').style.display = 'none';
    if (workNotesContainer) {
        workNotesContainer.style.display = 'none';
    }

    // Delete all items that have the class: layoutViewInputBox
    const layoutViewInputBoxes = document.querySelectorAll('.layoutViewInputBox');
    layoutViewInputBoxes.forEach(layoutViewInputBox => {
        layoutViewInputBox.remove();
    });

    // Get headers and sort them alphabetically
    const headers = Object.keys(originalData[0]).sort((a, b) => 
        a.toLowerCase().localeCompare(b.toLowerCase())
    );
    
    // Create container
    const container = document.createElement('div');
    container.id = 'allColumnsView';  // Add this specific ID
    container.style.cssText = `
        padding: 20px;
        margin: 20px;
        background: var(--background-color);
        border-radius: 8px;
        font-family: Arial, sans-serif;
        color: var(--text-color);
    `;

    // Create collapsible header
    const headerDiv = document.createElement('div');
    headerDiv.style.cssText = `
        display: flex;
        align-items: center;
        cursor: pointer;
        padding: 10px;
        background: var(--header-bg);
        border-radius: 4px;
        margin-bottom: 10px;
    `;

    const collapseIcon = document.createElement('span');
    collapseIcon.textContent = '▼';
    collapseIcon.style.marginRight = '10px';
    collapseIcon.style.transition = 'transform 0.3s';
    collapseIcon.style.transform = 'rotate(-90deg)'; // Start rotated

    const title = document.createElement('h2');
    title.textContent = "Available Columns";
    title.style.color = 'var(--text-color)';
    title.style.margin = '0';

    headerDiv.appendChild(collapseIcon);
    headerDiv.appendChild(title);

    // Create list
    const list = document.createElement('ul');
    list.style.cssText = `
        list-style: none;
        padding: 0;
        margin: 0;
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease-out;
    `;

    // Create table container
    const tableContainer = document.createElement('div');
    tableContainer.style.marginTop = '20px';
    tableContainer.style.overflowX = 'auto';

    // Create table
    const table = document.createElement('table');
    table.id = 'dynamicTable';
    table.style.width = '100%';
    table.style.borderCollapse = 'collapse';
    table.className = 'display';

    let dataTable; // Will hold our DataTable instance

    // Function to update table based on checkbox states
    function updateTable() {
        // Properly destroy existing DataTable if it exists
        if ($.fn.DataTable.isDataTable('#dynamicTable')) {
            $('#dynamicTable').DataTable().destroy();
        }
        table.innerHTML = ''; // Clear existing table content

        // Get checked headers
        const checkedBoxes = Array.from(list.querySelectorAll('input:checked'));
        const visibleHeaders = checkedBoxes.map(cb => cb.dataset.header);

        if (visibleHeaders.length === 0) {
            table.innerHTML = '<tr><td>No columns selected</td></tr>';
            return;
        }

        // Create header row
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        visibleHeaders.forEach(header => {
            const th = document.createElement('th');
            th.textContent = header;
            th.style.padding = '8px';
            th.style.border = '1px solid var(--border-color)';
            headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);

        // Create table body
        const tbody = document.createElement('tbody');
        originalData.forEach(item => {
            const row = document.createElement('tr');
            visibleHeaders.forEach(header => {
                const td = document.createElement('td');
                let value = item[header];
                
                // Handle special cases like accessories
                if (header === 'accessories' && Array.isArray(value)) {
                    value = value.map(acc => acc.type || acc.inst_type || '').join(', ');
                }
                
                td.textContent = value || '';
                td.style.padding = '8px';
                td.style.border = '1px solid var(--border-color)';
                row.appendChild(td);
            });
            tbody.appendChild(row);
        });
        table.appendChild(tbody);

        // Initialize new DataTable
        dataTable = $(table).DataTable({
            searching: false,
            paging: false,
            info: false,
            scrollX: true,
            order: [],
            columnDefs: [{
                targets: '_all',
                orderable: true
            }]
        });
    }

    // Create checkboxes and add to list
    headers.forEach(header => {
        const item = document.createElement('li');
        item.style.cssText = `
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
            font-size: 16px;
            display: flex;
            align-items: center;
        `;

        // Create checkbox
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = false; // Start with all checkboxes unchecked
        checkbox.dataset.header = header;
        checkbox.style.marginRight = '10px';
        checkbox.style.cursor = 'pointer';

        // Add change event to update table
        checkbox.addEventListener('change', () => {
            updateTable();
        });

        // Create label
        const label = document.createElement('label');
        label.textContent = header;
        label.style.cursor = 'pointer';
        label.style.flexGrow = '1';

        // Add click handler to label
        label.addEventListener('click', (e) => {
            e.preventDefault(); // Prevent default label behavior
            checkbox.checked = !checkbox.checked;
            updateTable();
        });

        item.appendChild(checkbox);
        item.appendChild(label);
        list.appendChild(item);
    });

    // Add collapse functionality
    let isCollapsed = true; // Start collapsed
    headerDiv.addEventListener('click', () => {
        isCollapsed = !isCollapsed;
        if (isCollapsed) {
            list.style.maxHeight = '0';
            list.style.overflow = 'hidden';
            collapseIcon.style.transform = 'rotate(-90deg)';
        } else {
            list.style.maxHeight = '500px';
            list.style.overflow = 'auto';
            collapseIcon.style.transform = 'rotate(0deg)';
        }
    });

    // Assemble everything
    container.appendChild(headerDiv);
    container.appendChild(list);
    tableContainer.appendChild(table);
    container.appendChild(tableContainer);
    document.body.appendChild(container);

    // Initialize table with all columns
    updateTable();
}

function checkAddresses() {
    // Filter instruments with no address or address = 0
    const noAddressInstruments = originalData.filter(instrument => 
        !instrument.absolute_address || 
        instrument.absolute_address === "0" ||
        instrument.absolute_address === 0
    );

    if (noAddressInstruments.length === 0) {
        alert('All instruments have addresses assigned.');
        return;
    }

    // Create modal overlay
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--modal-overlay);
        display: flex;
        justify-content: center;
        align-items: flex-start;
        overflow-y: auto;
        z-index: 1000;
    `;

    // Create content container
    const content = document.createElement('div');
    content.style.cssText = `
        background: var(--modal-bg);
        color: var(--text-color);
        padding: 20px;
        margin: 20px;
        border-radius: 8px;
        max-width: 95%;
        max-height: 90vh;
        overflow-y: auto;
        position: relative;
    `;

    // Add close and save buttons
    const buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = `
        position: sticky;
        top: 0;
        right: 0;
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        background: var(--modal-bg);
        padding: 5px;
        z-index: 2;
    `;

    const saveButton = document.createElement('button');
    saveButton.innerHTML = 'Save Changes';
    saveButton.style.cssText = `
        padding: 5px 10px;
        background: #4CAF50;
        color: var(--text-color);
        border: none;
        border-radius: 4px;
        cursor: pointer;
    `;

    const closeButton = document.createElement('button');
    closeButton.innerHTML = '×';
    closeButton.style.cssText = `
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        padding: 5px;
        color: var(--text-color);
    `;

    // Create the content HTML
    content.innerHTML = `
        <style>
            .address-table { 
                width: 100%; 
                border-collapse: collapse; 
                margin-top: 20px; 
            }
            .address-table th, .address-table td { 
                border: 1px solid var(--border-color); 
                padding: 8px; 
                text-align: left; 
            }
            .address-table th { 
                background-color: var(--header-bg); 
                color: var(--text-color);
                position: sticky;
                top: 40px;
                z-index: 1;
            }
            .address-input {
                width: 80px;
                padding: 4px;
                border: 1px solid var(--border-color);
                border-radius: 4px;
                background-color: var(--input-bg);
                color: var(--text-color);
            }
            h1 { 
                color: var(--text-color);
                margin-right: 40px; 
            }
            .invalid-input {
                border-color: red;
                background-color: var(--error-bg);
            }
        </style>
        <h1>Instruments Missing Addresses (${noAddressInstruments.length} items)</h1>
        <table class="address-table">
            <tr>
                <th>Channel</th>
                <th>Position</th>
                <th>Unit</th>
                <th>Purpose</th>
                <th>Type</th>
                <th>Dimmer</th>
                <th>Color</th>
                <th>New Address</th>
            </tr>
            ${noAddressInstruments.map((row, index) => `
                <tr>
                    <td>${row.channel || ''}</td>
                    <td>${row.position || ''}</td>
                    <td>${row.unit || row.unit_number || ''}</td>
                    <td>${row.purpose || ''}</td>
                    <td>${row.type || row.inst_type || ''}</td>
                    <td>${row.dimmer || ''}</td>
                    <td>${row.color || ''}</td>
                    <td>
                        <input type="number" 
                               class="address-input" 
                               data-index="${index}"
                               min="1"
                               placeholder="Enter address">
                    </td>
                </tr>
            `).join('')}
        </table>
    `;

    // Add save functionality
    saveButton.onclick = () => {
        const inputs = content.querySelectorAll('.address-input');
        let hasInvalidInputs = false;

        inputs.forEach(input => {
            const value = parseInt(input.value);
            if (input.value && (isNaN(value) || value < 1)) {
                input.classList.add('invalid-input');
                hasInvalidInputs = true;
            } else {
                input.classList.remove('invalid-input');
            }
        });

        if (hasInvalidInputs) {
            alert('Please enter valid addresses (positive numbers only).');
            return;
        }

        // Update addresses in originalData
        inputs.forEach(input => {
            if (input.value) {
                const index = parseInt(input.dataset.index);
                const instrument = noAddressInstruments[index];
                const originalIndex = originalData.findIndex(item => 
                    item.channel === instrument.channel &&
                    item.position === instrument.position &&
                    item.unit === instrument.unit
                );

                if (originalIndex !== -1) {
                    originalData[originalIndex].absolute_address = input.value;
                    originalData[originalIndex].address = input.value;
                }
            }
        });

        // Update the main table
        resetSearch();
        
        // Close modal
        document.body.removeChild(modal);
    };

    // Add close functionality
    closeButton.onclick = () => document.body.removeChild(modal);

    // Add close on outside click
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            document.body.removeChild(modal);
        }
    });

    // Add buttons and content to modal
    buttonContainer.appendChild(saveButton);
    buttonContainer.appendChild(closeButton);
    content.insertBefore(buttonContainer, content.firstChild);
    modal.appendChild(content);

    // Add modal to page
    document.body.appendChild(modal);
}

function checkChannels() {
    // Filter instruments with no channel or channel = 0
    const noChannelInstruments = originalData.filter(instrument => 
        !instrument.channel ||
        instrument.channel === "0" ||
        instrument.channel === 0
    );

    if (noChannelInstruments.length === 0) {
        alert('All instruments have channels assigned.');
        return;
    }

    // Create modal overlay
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--modal-overlay);
        display: flex;
        justify-content: center;
        align-items: flex-start;
        overflow-y: auto;
        z-index: 1000;
    `;

    // Create content container
    const content = document.createElement('div');
    content.style.cssText = `
        background: var(--modal-bg);
        color: var(--text-color);
        padding: 20px;
        margin: 20px;
        border-radius: 8px;
        max-width: 95%;
        max-height: 90vh;
        overflow-y: auto;
        position: relative;
    `;

    // Add close and save buttons
    const buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = `
        position: sticky;
        top: 0;
        right: 0;
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        background: var(--modal-bg);
        padding: 5px;
        z-index: 2;
    `;

    const saveButton = document.createElement('button');
    saveButton.innerHTML = 'Save Changes';
    saveButton.style.cssText = `
        padding: 5px 10px;
        background: var(--button-bg);
        color: var(--button-text);
        border: none;
        border-radius: 4px;
        cursor: pointer;
    `;

    const closeButton = document.createElement('button');
    closeButton.innerHTML = '×';
    closeButton.style.cssText = `
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        padding: 5px;
        color: var(--text-color);
    `;

    // Create the content HTML
    content.innerHTML = `
        <style>
            .channel-table { 
                width: 100%; 
                border-collapse: collapse; 
                margin-top: 20px; 
            }
            .channel-table th, .channel-table td { 
                border: 1px solid var(--border-color); 
                padding: 8px; 
                text-align: left; 
            }
            .channel-table th { 
                background-color: var(--header-bg); 
                color: var(--text-color);
                position: sticky;
                top: 40px;
                z-index: 1;
            }
            .channel-input {
                width: 80px;
                padding: 4px;
                border: 1px solid var(--border-color);
                border-radius: 4px;
                background-color: var(--input-bg);
                color: var(--text-color);
            }
            h1 { 
                color: var(--text-color);
                margin-right: 40px; 
            }
            .invalid-input {
                border-color: red;
                background-color: var(--error-bg);
            }
        </style>
        <h1>Instruments Missing Channels (${noChannelInstruments.length} items)</h1>
        <table class="channel-table">
            <tr>
                <th>Position</th>
                <th>Unit</th>
                <th>Purpose</th>
                <th>Type</th>
                <th>Address</th>
                <th>Color</th>
                <th>New Channel</th>
            </tr>
            ${noChannelInstruments.map((row, index) => `
                <tr>
                    <td>${row.position || row.pos || ''}</td>
                    <td>${row.unit || row.unit_number || ''}</td>
                    <td>${row.purpose || ''}</td>
                    <td>${row.type || row.inst_type || ''}</td>
                    <td>${row.address || row.absolute_address || ''}</td>
                    <td>${row.color || ''}</td>
                    <td>
                        <input type="number" 
                               class="channel-input" 
                               data-index="${index}"
                               min="1"
                               placeholder="Enter channel">
                    </td>
                </tr>
            `).join('')}
        </table>
    `;

    // Add save functionality
    saveButton.onclick = () => {
        const inputs = content.querySelectorAll('.channel-input');
        let hasInvalidInputs = false;

        inputs.forEach(input => {
            const value = parseInt(input.value);
            if (input.value && (isNaN(value) || value < 1)) {
                input.classList.add('invalid-input');
                hasInvalidInputs = true;
            } else {
                input.classList.remove('invalid-input');
            }
        });

        if (hasInvalidInputs) {
            alert('Please enter valid channels (positive numbers only).');
            return;
        }

        // Update channels in originalData
        inputs.forEach(input => {
            if (input.value) {
                const index = parseInt(input.dataset.index);
                const instrument = noChannelInstruments[index];
                const originalIndex = originalData.findIndex(item => 
                    item.position === instrument.position &&
                    item.unit === instrument.unit
                );

                if (originalIndex !== -1) {
                    originalData[originalIndex].channel = input.value;
                    originalData[originalIndex].chan = input.value;
                }
            }
        });

        // Update the main table
        resetSearch();
        
        // Close modal
        document.body.removeChild(modal);
    };

    // Add close functionality
    closeButton.onclick = () => document.body.removeChild(modal);

    // Add close on outside click
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            document.body.removeChild(modal);
        }
    });

    // Add buttons and content to modal
    buttonContainer.appendChild(saveButton);
    buttonContainer.appendChild(closeButton);
    content.insertBefore(buttonContainer, content.firstChild);
    modal.appendChild(content);

    // Add modal to page
    document.body.appendChild(modal);
}

function checkDimmerWattage() {
    // Create a map to store dimmer information
    const dimmerMap = new Map();

    // Collect all instruments grouped by dimmer
    originalData.forEach(instrument => {
        const dimmer = instrument.dimmer;
        if (!dimmer || dimmer === "0") return; // Skip instruments with no dimmer

        // Get wattage directly from the instrument data
        let wattage = instrument.wattage;
        wattage = wattage.replace(/w/i, ''); // Remove 'w' or 'W' from the end or anywhere in the string
        const parsedWattage = parseInt(wattage) || 0;

        // Add instrument to dimmer map
        if (!dimmerMap.has(dimmer)) {
            dimmerMap.set(dimmer, []);
        }
        dimmerMap.get(dimmer).push({
            channel: instrument.channel || instrument.chan,
            type: instrument.type || instrument.inst_type,
            wattage: parsedWattage,
            position: instrument.position || instrument.pos,
            unit: instrument.unit || instrument.unit_number
        });
    });

    // Create modal for display
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--modal-overlay);
        display: flex;
        justify-content: center;
        align-items: flex-start;
        overflow-y: auto;
        z-index: 1000;
    `;

    // Create content container
    const content = document.createElement('div');
    content.style.cssText = `
        background: var(--modal-bg);
        color: var(--text-color);
        padding: 20px;
        margin: 20px;
        border-radius: 8px;
        max-width: 95%;
        max-height: 90vh;
        overflow-y: auto;
        position: relative;
    `;

    // Sort dimmers numerically
    const sortedDimmers = Array.from(dimmerMap.keys()).sort((a, b) => parseInt(a) - parseInt(b));

    // Create the content HTML
    content.innerHTML = `
        <style>
            .dimmer-table { 
                width: 100%; 
                border-collapse: collapse; 
                margin-top: 20px; 
            }
            .dimmer-table th, .dimmer-table td { 
                border: 1px solid var(--border-color); 
                padding: 8px; 
                text-align: left; 
            }
            .dimmer-table th { 
                background-color: var(--header-bg);
                color: var(--text-color);
                position: sticky;
                top: 40px;
                z-index: 1;
            }
            .warning {
                background-color: var(--warning-bg);
            }
            h1 { 
                color: var(--text-color);
                margin-right: 40px; 
            }
        </style>
        <h1>Dimmer Load Analysis</h1>
        <table class="dimmer-table">
            <tr>
                <th>Dimmer</th>
                <th>Total Load</th>
                <th>Instruments</th>
            </tr>
            ${sortedDimmers.map(dimmer => {
                const instruments = dimmerMap.get(dimmer);
                const totalWattage = instruments.reduce((sum, inst) => sum + inst.wattage, 0);
                const isOverloaded = totalWattage > 2400; // Standard dimmer capacity

                return `
                    <tr class="${isOverloaded ? 'warning' : ''}">
                        <td>${dimmer}</td>
                        <td>${totalWattage}W ${isOverloaded ? '⚠️' : ''}</td>
                        <td>${instruments.map(inst => 
                            `Channel ${inst.channel} (${inst.type} - ${inst.wattage}W) @ ${inst.position} U${inst.unit}`
                        ).join('<br>')}</td>
                    </tr>
                `;
            }).join('')}
        </table>
    `;

    // Add close button
    const closeButton = document.createElement('button');
    closeButton.innerHTML = '×';
    closeButton.style.cssText = `
        position: absolute;
        top: 10px;
        right: 10px;
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        padding: 5px;
        color: var(--text-color);
    `;
    closeButton.onclick = () => document.body.removeChild(modal);

    // Add close on outside click
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            document.body.removeChild(modal);
        }
    });

    content.insertBefore(closeButton, content.firstChild);
    modal.appendChild(content);
    document.body.appendChild(modal);
}

function checkChannelWattage() {
    // Create a map to store channel information
    const channelMap = new Map();

    // Collect all instruments grouped by channel
    originalData.forEach(instrument => {
        const channel = instrument.channel || instrument.chan;
        if (!channel || channel === "0") return; // Skip instruments with no channel

        // Get wattage directly from the instrument data
        let wattage = instrument.wattage;
        wattage = wattage.replace(/w/i, ''); // Remove 'w' or 'W' from the end or anywhere in the string
        const parsedWattage = parseInt(wattage) || 0;

        // Add instrument to channel map
        if (!channelMap.has(channel)) {
            channelMap.set(channel, []);
        }
        channelMap.get(channel).push({
            dimmer: instrument.dimmer,
            type: instrument.type || instrument.inst_type,
            wattage: parsedWattage,
            position: instrument.position || instrument.pos,
            unit: instrument.unit || instrument.unit_number
        });
    });

    // Create modal for display
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--modal-overlay);
        display: flex;
        justify-content: center;
        align-items: flex-start;
        overflow-y: auto;
        z-index: 1000;
    `;

    // Create content container
    const content = document.createElement('div');
    content.style.cssText = `
        background: var(--modal-bg);
        color: var(--text-color);
        padding: 20px;
        margin: 20px;
        border-radius: 8px;
        max-width: 95%;
        max-height: 90vh;
        overflow-y: auto;
        position: relative;
    `;

    // Sort channels numerically
    const sortedChannels = Array.from(channelMap.keys()).sort((a, b) => parseInt(a) - parseInt(b));

    // Create the content HTML
    content.innerHTML = `
        <style>
            .channel-table { 
                width: 100%; 
                border-collapse: collapse; 
                margin-top: 20px; 
            }
            .channel-table th, .channel-table td { 
                border: 1px solid var(--border-color); 
                padding: 8px; 
                text-align: left; 
            }
            .channel-table th { 
                background-color: var(--header-bg);
                color: var(--text-color);
                position: sticky;
                top: 40px;
                z-index: 1;
            }
            .warning {
                background-color: var(--warning-bg);
            }
            h1 { 
                color: var(--text-color);
                margin-right: 40px; 
            }
        </style>
        <h1>Channel Load Analysis</h1>
        <p>Total number of dimmers used: ${sortedChannels.length}</p>
        <table class="channel-table">
            <tr>
                <th>Channel</th>
                <th>Total Load</th>
                <th>Instruments</th>
            </tr>
            ${sortedChannels.map(channel => {
                const instruments = channelMap.get(channel);
                const totalWattage = instruments.reduce((sum, inst) => sum + inst.wattage, 0);
                const isOverloaded = totalWattage > 2400; // Standard dimmer capacity

                return `
                    <tr class="${isOverloaded ? 'warning' : ''}">
                        <td>${channel}</td>
                        <td>${totalWattage}W ${isOverloaded ? '⚠️' : ''}</td>
                        <td>${instruments.map(inst => 
                            `Dimmer ${inst.dimmer} (${inst.type} - ${inst.wattage}W) @ ${inst.position} U${inst.unit}`
                        ).join('<br>')}</td>
                    </tr>
                `;
            }).join('')}
        </table>
    `;

    // Add close button
    const closeButton = document.createElement('button');
    closeButton.innerHTML = '×';
    closeButton.style.cssText = `
        position: absolute;
        top: 10px;
        right: 10px;
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        padding: 5px;
        color: var(--text-color);
    `;
    closeButton.onclick = () => document.body.removeChild(modal);

    // Add close on outside click
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            document.body.removeChild(modal);
        }
    });

    // Add button to ask for wattage limit
    const wattageLimitButton = document.createElement('button');
    wattageLimitButton.innerHTML = 'Set Wattage Limit';
    wattageLimitButton.style.cssText = `
        position: absolute;
        top: 50px;
        right: 10px;
        background: var(--button-bg);
        border: none;
        font-size: 16px;
        cursor: pointer;
        padding: 5px 10px;
        color: var(--text-color);
    `;
    wattageLimitButton.onclick = () => {
        const wattageLimit = prompt('Enter the wattage limit (default is 2400):', 2400);
        if (wattageLimit) {
            // Update the warning class based on the new wattage limit
            document.querySelectorAll('.channel-table tr').forEach((tr, index) => {
                const totalWattage = sortedChannels[index].reduce((sum, inst) => sum + inst.wattage, 0);
                if (totalWattage > parseInt(wattageLimit)) {
                    tr.classList.add('warning');
                } else {
                    tr.classList.remove('warning');
                }
            });
            // Save the new wattage limit for future use
            localStorage.setItem('wattageLimit', wattageLimit);
        }
    };

    content.insertBefore(closeButton, content.firstChild);
    content.insertBefore(wattageLimitButton, content.firstChild);
    modal.appendChild(content);
    document.body.appendChild(modal);
}

function getSystemColorMode() {
    const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches;
    return isDarkMode ? "dark" : "light";
}

function quickColor() {
    const colorCounts = {};
    originalData.forEach((instrument) => {
        const instrumentType = instrument.type || instrument.inst_type;
        const color = instrument.color;
        if (!colorCounts[color]) {
            colorCounts[color] = {};
        }
        if (!colorCounts[color][instrumentType]) {
            colorCounts[color][instrumentType] = 0;
        }
        colorCounts[color][instrumentType]++;
    });

    // Sort colors before creating the table
    const sortedColors = Object.keys(colorCounts).sort();

    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80%;
        max-height: 80%;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: auto;
    `;

    const content = document.createElement('div');
    content.style.cssText = `
        background: var(--background-color);
        padding: 20px;
        border: 1px solid var(--border-color);
        border-radius: 10px;
        box-shadow: 0px 8px 16px 0px var(--menu-shadow);
        max-height: 100%;
        overflow: auto;
        padding-top: 300px; /* Adjusted to ensure the top of the table is not cut off */
    `;

    const closeButton = document.createElement('button');
    closeButton.innerHTML = '×';
    closeButton.style.cssText = `
        position: absolute;
        top: 10px;
        right: 10px;
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        padding: 5px;
        color: var(--text-color);
    `;
    closeButton.onclick = () => document.body.removeChild(modal);

    const table = document.createElement('table');
    table.style.cssText = `
        border-collapse: collapse;
        width: 100%;
    `;

    const thead = document.createElement('thead');
    const tr = document.createElement('tr');
    const th1 = document.createElement('th');
    th1.innerHTML = 'Color';
    const th2 = document.createElement('th');
    th2.innerHTML = 'Instrument Type';
    const th3 = document.createElement('th');
    th3.innerHTML = 'Count';
    tr.appendChild(th1);
    tr.appendChild(th2);
    tr.appendChild(th3);
    thead.appendChild(tr);

    const tbody = document.createElement('tbody');
    sortedColors.forEach((color) => {
        Object.keys(colorCounts[color]).forEach((instrumentType) => {
            const tr = document.createElement('tr');
            const td1 = document.createElement('td');
            td1.innerHTML = color;
            const td2 = document.createElement('td');
            td2.innerHTML = instrumentType;
            const td3 = document.createElement('td');
            td3.innerHTML = colorCounts[color][instrumentType];
            tr.appendChild(td1);
            tr.appendChild(td2);
            tr.appendChild(td3);
            tbody.appendChild(tr);
        });
    });

    table.appendChild(thead);
    table.appendChild(tbody);

    content.appendChild(closeButton);
    content.appendChild(table);
    modal.appendChild(content);
    document.body.appendChild(modal);

    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            document.body.removeChild(modal);
        }
    });
}

function quickInstrument() { // Duplicate of quickColor for counting Instrument Types
    const typeCounts = {};
    originalData.forEach((instrument) => {
        const instrumentType = instrument.type || instrument.inst_type;
        if (!typeCounts[instrumentType]) {
            typeCounts[instrumentType] = 0;
        }
        typeCounts[instrumentType]++;
    });

    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80%;
        max-height: 80%;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: auto;
    `;

    const content = document.createElement('div');
    content.style.cssText = `
        background: var(--background-color);
        padding: 20px;
        border: 1px solid var(--border-color);
        border-radius: 10px;
        box-shadow: 0px 8px 16px 0px var(--menu-shadow);
        max-height: 100%;
        overflow: auto;
    `;

    const closeButton = document.createElement('button');
    closeButton.innerHTML = '×';
    closeButton.style.cssText = `
        position: absolute;
        top: 10px;
        right: 10px;
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        padding: 5px;
        color: var(--text-color);
    `;
    closeButton.onclick = () => document.body.removeChild(modal);

    const table = document.createElement('table');
    table.style.cssText = `
        border-collapse: collapse;
        width: 100%;
    `;

    const thead = document.createElement('thead');
    const tr = document.createElement('tr');
    const th1 = document.createElement('th');
    th1.innerHTML = 'Instrument Type';
    const th2 = document.createElement('th');
    th2.innerHTML = 'Count';
    tr.appendChild(th1);
    tr.appendChild(th2);
    thead.appendChild(tr);

    const tbody = document.createElement('tbody');
    let totalInstruments = 0;
    Object.keys(typeCounts).forEach((instrumentType) => {
        const tr = document.createElement('tr');
        const td1 = document.createElement('td');
        td1.innerHTML = instrumentType;
        const td2 = document.createElement('td');
        td2.innerHTML = typeCounts[instrumentType];
        tr.appendChild(td1);
        tr.appendChild(td2);
        tbody.appendChild(tr);
        totalInstruments += typeCounts[instrumentType];
    });

    // Add a total instruments row
    const totalRow = document.createElement('tr');
    const totalTd1 = document.createElement('td');
    totalTd1.innerHTML = 'Total Instruments';
    const totalTd2 = document.createElement('td');
    totalTd2.innerHTML = totalInstruments;
    totalRow.appendChild(totalTd1);
    totalRow.appendChild(totalTd2);
    tbody.appendChild(totalRow);

    table.appendChild(thead);
    table.appendChild(tbody);

    content.appendChild(closeButton);
    content.appendChild(table);
    modal.appendChild(content);
    document.body.appendChild(modal);

    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            document.body.removeChild(modal);
        }
    });
}

const layers = []; // Array to hold the layers
const layerColors = []; // Array to hold the colors for each layer
let displayedData = []; // Array to hold the currently displayed data

function getRandomColor() {
    const letters = '0123456789ABCDEF';
    let color = '#';
    for (let i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
    }
    if (color.startsWith('#FF') || color.startsWith('#F0') || color.startsWith('#E0')){// || color.startsWith('#D0') || color.startsWith('#C0')) { // Avoid a range of reds
        color = getRandomColor(); // If the color is in the range of reds, get a new one
    }
    return color;
}

function addLayer() {
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.xml';
    fileInput.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) {
            alert('Please select an XML file.');
            return;
        }

        const reader = new FileReader();
        reader.onload = function(event) {
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(event.target.result, "text/xml");

                const instrumentData = xmlDoc.querySelector("InstrumentData");
                const instruments = instrumentData ? Array.from(instrumentData.children) : [];

                if (instruments.length <= 0) {
                    alert("No instrument entries found in the XML file.");
                    return;
                }

                // Clear existing table if displayed
                const tableBody = document.getElementById('tableBody');
                tableBody.innerHTML = ''; // Clear existing rows

                // Parse the new data and merge with original data
                const newData = [];
                instruments.forEach((instrument, index) => {
                    if (index >= 5) { // Skip the first 5 entries
                        const fullData = {};
                        Array.from(instrument.children).forEach(child => {
                            fullData[child.tagName.toLowerCase()] = child.textContent || '';
                        });
                        newData.push(fullData);
                    }
                });

                // Generate a random color for the new layer
                const layerColor = getRandomColor();
                layerColors.push(layerColor); // Save the color in the layerColors array

                // Add the new layer to the layers array
                layers.push({ name: file.name, data: newData, visible: true });

                // Create a new button for the layer in the dropdown
                const layerIndex = layers.length; // Capture the current index before pushing the layer
                const layerButton = document.createElement('a');
                layerButton.href = '#';
                layerButton.innerText = file.name;
                layerButton.style.color = layerColor; // Set the button color to the layer's color
                layerButton.onclick = function() {
                    toggleLayerVisibility(layerIndex - 1, layerButton); // Pass the correct index to toggleLayerVisibility
                };
                document.getElementById('layersDropdown').appendChild(layerButton);


                // Populate the merged data into the table
                populateTableLayers();

            } catch (error) {
                console.error("Error parsing XML file:", error);
                alert("An error occurred while processing the XML file. Please check the console for details.");
            }
        };

        reader.readAsText(file);
    };
    fileInput.click(); // Trigger the file input dialog
}

function populateTableLayers() {
    const tableBody = document.getElementById('tableBody');
    tableBody.innerHTML = ''; // Clear existing rows

    // Rebuild the displayed data based on visibility
    displayedData = [...originalData]; // Start with original data

    layers.forEach((layer, index) => {
        if (layer.visible) {
            // Add the layer data to displayedData if it's visible
            layer.data.forEach(item => {
                item.source = index; // Assign the layer index to the item
                displayedData.push(item);
            });
        }
    });

    // Populate the merged data into the table
    displayedData.forEach(item => {
        const accessoriesText = Array.isArray(item.accessories) 
            ? item.accessories.map(acc => acc.type || acc.inst_type || "Unknown").join("; ")
            : typeof item.accessories === 'string' 
                ? item.accessories 
                : "";

        // Determine the background color based on the layer's color
        const rowColor = item.source !== undefined ? layerColors[item.source] : 'transparent';

        const row = `<tr style="background-color: ${rowColor};"> <!-- Color for layered data -->
            <td>${item.channel || item.chan || ''}</td>
            <td>${item.position || item.pos || ''}</td>
            <td>${item.unit || item.unit_number || ''}</td>
            <td>${item.purpose || ''}</td>
            <td>${item.type || item.inst_type || ''}</td>
            <td>${item.dimmer || ''}</td>
            <td>${item.address || item.absolute_address || ''}</td>
            <td>${item.color || ''}</td>
            <td>${item.gobo || item.template || ''}</td>
            <td>${item.wattage || ''}</td>
            <td>${accessoriesText}</td>
        </tr>`;
        tableBody.innerHTML += row;
    });

    // Refresh the DataTable
    $('#dataTable').DataTable().clear().rows.add($(tableBody).children()).draw();
}


function toggleLayerVisibility(layerIndex, layerButton) {
    // Toggle the visibility of the layer
    layers[layerIndex].visible = !layers[layerIndex].visible;

    // Update button color based on visibility
    layerButton.style.color = layers[layerIndex].visible 
        ? layerColors[layerIndex] // Restore the original color when visible
        : 'red'; // Change color to red when hidden

    // Repopulate the table based on updated visibility
    populateTableLayers();
}

function layoutView() {
    // Hide the original DataTable
    document.getElementById('dataTable').style.display = 'none';


    //Channel Hookup
    const labelChan = document.createElement('label');
    labelChan.textContent = 'Channel Hookup Lines Per Page';
    labelChan.style.marginTop = '20px';
    labelChan.classList.add('layoutViewInputBox');
    document.body.appendChild(labelChan);

    const channelLines = document.createElement('input');
    channelLines.type = 'number';
    channelLines.placeholder = layoutLimits.channel;
    channelLines.style.width = '300px';
    channelLines.classList.add('layoutViewInputBox'); // Added class for easy deletion
    document.body.appendChild(channelLines);

    //Instrument Schedule
    const labelIntr = document.createElement('label');
    labelIntr.textContent = 'Instrument Schedule Lines Per Page';
    labelIntr.classList.add('layoutViewInputBox');
    document.body.appendChild(labelIntr);

    const intrLines = document.createElement('input');
    intrLines.type = 'number';
    intrLines.placeholder = layoutLimits.instrument;
    intrLines.style.width = '300px';
    intrLines.classList.add('layoutViewInputBox'); // Added class for easy deletion
    document.body.appendChild(intrLines);

    const updateLayoutLimitsButton = document.createElement('button');
    updateLayoutLimitsButton.textContent = 'Update Layout Limits';
    updateLayoutLimitsButton.style.marginTop = '20px';
    updateLayoutLimitsButton.style.cursor = 'pointer';
    updateLayoutLimitsButton.classList.add('layoutViewInputBox');
    document.body.appendChild(updateLayoutLimitsButton);

    updateLayoutLimitsButton.onclick = function() {
        layoutLimits.channel = parseInt(channelLines.value);
        layoutLimits.instrument = parseInt(intrLines.value);
        alert('Layout limits updated successfully.');
    };
}



</script>

</body>
</html>